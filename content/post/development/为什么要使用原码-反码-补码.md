---
title: 为什么要使用原码 反码 补码.
author: "-"
date: 2011-07-03T07:46:41+00:00
url: /?p=303
categories:
  - Computer Science
tags:
  - reprint
---
## 为什么要使用原码 反码 补码.
前言: 随着学习计算机知识的加深，许多地方都遇到原码、反码、补码。很多关于计算机的书籍都介绍原码、反码、补码的表示方法，但是为什么要用到原码、反码、补码却没详细说。为什么要使用？它们的原理是什么呢?我搜索了许多资料，也查找了许多书籍，终于弄明白了这个问题，收集整理如下。

我们知道数值在计算机中表示形式为机器数，计算机只能识别0和1，使用的是二进制。而在日常生活中人们使用的是十进制，并且我们用的数值有正负之分。于是在计算机中就用一个数的最高位存放符号(0为正，1为负)。这就是机器数的原码了。

有了数值的表示方法就可以对数进行算术运算，但是很快就发现用带符号位的原码进行乘除运算时结果正确，而在加减运算的时候就出现了问题，如下: 假设字长为8bits

(1) <sub>10</sub> - (1)<sub>10</sub> = (1)<sub>10</sub> + (-1)<sub>10</sub> = (0)<sub>10</sub>

(0 0000001)<sub>原</sub> + (1 0000001)<sub>原</sub> = (1 0000010)<sub>原</sub> = ( -2 )显然不正确。

因为在两个整数的加法运算中是没有问题的，于是就发现问题出现在带符号位的负数身上。对除符号位外的其余各位逐位取反就产生了反码。反码的取值空间和原码相同且一一对应。下面是反码的减法运算: 

(1)<sub>10</sub> - (1)<sub>10</sub> = (1)<sub>10</sub> + (-1)<sub>10</sub> = (0)<sub>10</sub>

(0 0000001)<sub>反</sub> + (1 1111110)<sub>反</sub> = (1 1111111)<sub>反</sub> = ( -0 )有问题。

(1)<sub>10</sub> - (2)<sub>10</sub> = (1)<sub>10</sub> + (-2)<sub>10</sub> = (-1)<sub>10</sub>

(0 0000001)<sub>反</sub> + (1 1111101)<sub>反</sub> = (11111110)<sub>反</sub> = (-1)正确。

问题出现在(+0)和(-0)上，在人们的计算概念中零是没有正负之分的。 (印度人首先将零作为标记并放入运算之中，包含有零号的印度数学和十进制计数对人类文明的贡献极大) 。

于是就引入了补码概念。负数的补码就是对反码加一，而正数的补码不变，正数的原码反码补码是一样的。在补码中用(-128)代替了(-0)，这个是人为规定的，所以补码的表示范围为: 

(-128~0~127)共256个。

注意: (-128)没有相对应的原码和反码， (-128) = (1 0000000)  补码的加减运算如下: 

(1)<sub>10</sub> - (1)<sub>10</sub> = (1)<sub>10</sub> + (-1)<sub>10</sub> = (0)<sub>10</sub>

(0 0000001)<sub>补</sub> + (1 1111111)<sub>补</sub> = (0 0000000)<sub>补</sub> = ( 0 )正确。

(1)<sub>10</sub> - (2)<sub>10</sub> = (1)<sub>10</sub> + (-2)<sub>10</sub> = (-1)<sub>10</sub>

(00000001)<sub>补</sub> + (11111110)<sub>补</sub> = (11111111)<sub>补</sub> = (-1)正确。


所以补码的设计目的是: 

⑴ 使符号位能与有效值部分一起参加运算，从而简化运算规则。补码机器数中的符号位，并不是强加上去的，是数据本身的自然组成部分，可以正常地参与运算。

⑵ 使减法运算转换为加法运算，进一步简化计算机中运算器的线路设计。

所有这些转换都是在计算机的最底层进行的，而在我们使用的汇编、c 等其他高级语言中使用的都是原码。


