---
title: 偏向锁(Biased Locking)
author: "-"
date: 2013-09-13T11:07:15+00:00
url: /?p=5812
categories:
  - Java
tags:
  - reprint
---
## 偏向锁(Biased Locking)

Java偏向锁(Biased Locking) 是Java6引入的一项多线程优化。它通过消除资源无竞争情况下的同步原语,进一步提高了程序的运行性能。

轻量级锁也是一种多线程优化,它与偏向锁的区别在于,轻量级锁是通过CAS来避免进入开销较大的互斥操作,而偏向锁是在无竞争场景下完全消除同步,连CAS也不执行 (CAS本身仍旧是一种操作系统同步原语,始终要在JVM与OS之间来回,有一定的开销) 。

所谓的无竞争场景,举个例子,就是单线程访问带同步的资源或方法。

偏向锁实现原理
  
偏向锁,顾名思义,它会偏向于第一个访问锁的线程,如果在接下来的运行过程中,该锁没有被其他的线程访问,则持有偏向锁的线程将永远不需要触发同步。
  
如果在运行过程中,遇到了其他线程抢占锁,则持有偏向锁的线程会被挂起,JVM会尝试消除它身上的偏向锁,将锁恢复到标准的轻量级锁。(偏向锁只能在单线程下起作用)

偏向模式和非偏向模式,在下面的mark word表中,主要体现在thread ID字段是否为空。

挂起持有偏向锁的线程,这步操作类似GC的pause,但不同之处是,它只挂起持有偏向锁的线程 (非当前线程) 。

在抢占模式的橙色区域说明中有提到,指向当前堆栈中最近的一个lock record (在轻量级锁原理一文有讲到,lock record是进入锁前会在stack上创建的一份内存空间) 。
  
这里提到的最近的一个lock record,其实就是当前锁所在的stack frame上分配的lock record。
  
整个步骤是从偏向锁恢复到轻量级锁的过程。

偏向锁也会带来额外开销
  
在JDK6中,偏向锁是默认启用的。它提高了单线程访问同步资源的性能。
  
但试想一下,如果你的同步资源或代码一直都是多线程访问的,那么消除偏向锁这一步骤对你来说就是多余的。事实上,消除偏向锁的开销还是蛮大的。

所以在你非常熟悉自己的代码前提下,大可禁用偏向锁 -XX:-UseBiasedLocking 。

[http://blog.csdn.net/hsuxu/article/details/9472381](http://blog.csdn.net/hsuxu/article/details/9472381)
  
[http://www.cnblogs.com/paddix/p/5405678.html](http://www.cnblogs.com/paddix/p/5405678.html)
