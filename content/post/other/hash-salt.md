---
title: 密码，哈希，加盐 Adding Salt
author: "-"
date: 2015-06-28T06:52:56+00:00
url: hash/salt
tags:
  - Security
categories:
  - inbox
---
## 加密哈希函数

SHA256，SHA512，RipeMD， WHIRLPOOL， Bcrypt

>wiloon.com/bcrypt

什么是密码哈希函数？
A 密码哈希函数 是一组散列函数之一，适用于SSL /TLS。 像其他哈希函数一样，密码哈希函数是一种单向数学算法，用于将任何大小的数据映射到固定大小的位字符串。 加密哈希函数广泛用于信息安全实践中，例如数字签名，消息身份验证代码和其他形式的身份验证。 

加密哈希函数应具有以下属性 (来源： 维基百科):

1.相同的消息始终导致相同的哈希值 (即，函数为 确定性).
2.快速计算哈希值。
3.具有相同散列值的两个消息 (称为“冲突”）是不可行的。
4.故意创建产生给定哈希值的消息是不可行的。 
5.对消息的轻微更改应在很大​​程度上更改所得的哈希值，以使其看起来与原始哈希不相关。

最常用的加密哈希函数包括MD5，SHA-1和SHA-2。
每个哈希的唯一性对于密码哈希功能的完整性至关重要。 这才是真正将密码哈希函数与其他哈希函数区分开的地方-确保以唯一且不可复制的方式识别特定消息。 

数字签名方案 (例如 文件签署, 代码签名或 S/MIME 邮箱地址）通常要求对消息进行加密哈希计算并包含在签名中。 然后，收件人的软件将独立计算哈希值，以验证邮件的完整性。 

网站还经常发布可下载文件的哈希值。 用户下载文件时，可以使用自己的软件独立计算哈希值，从而验证文件的完整性。 

密码安全性还依赖于加密哈希。 用户提供的密码被散列，然后与存储的散列进行比较。 

加密哈希函数广泛用于安全协议，例如 SSL /TLS 和SSH，以及其他依赖数据完整性的应用程序。 加密货币使用哈希算法来使用新的安全可验证交易数据块更新区块链。  (例如，BitCoin使用SHA-2进行交易验证。）

什么是SHA-1？
SHA-1 (安全哈希算法1） 是一种加密哈希函数，可以将任意长的数据字符串转换为固定大小为160位的摘要。 该摘要通常显示为40个字符的十六进制数字。

SHA-1算法现已推出 被认为是不安全的。 SHA-1证书不再符合CA / B论坛基准要求，或不再受当前主要Web浏览器版本的支持。

安全哈希算法 (SHA）系列哈希函数由不同的集合 (SHA-0，SHA-1，SHA-2，SHA-3）组成。

什么是SHA-2？
SHA-2 (安全哈希算法2） “加密”是指可以将任意长数据串转换为固定大小 (224、256、384或512位）摘要的加密哈希函数系列。 256位SHA-2，也称为 SHA-256，是最常用的版本。 摘要通常显示为固定值的十六进制数。  (例如，SHA-256返回64个字符的代码。）

SHA-2在安全协议 (例如SSL /TLS.

## 查表法
查表法对于破解一系列算法相同的哈希值有着无与伦比的效率。主要的思想就是预计算密码字典中的每个密码，然后把哈希值和对应的密码储存到一个用于快速查询的数据结构中。一个良好的查表实现可以每秒进行数百次哈希查询，即使表中储存了几十亿个哈希值。

## 反向查表法
这种方法可以使攻击者同时对多个哈希值发起字典攻击或暴力攻击，而不需要预先计算出一个查询表。

首先攻击者构造一个基于密码-用户名的一对多的表，当然数据需要从某个已经被入侵的数据库获得，然后猜测一系列哈希值并且从表中查找拥有此密码的用户。通常许多用户可能有着相同的密码，因此这种攻击方式也显得尤为有效。

## 加盐 Adding Salt
http://drops.wooyun.org/papers/1066

查表和彩虹表的方式之所以有效是因为每一个密码的都是通过同样的方式来进行hash的。如果两个用户使用了同样的密码，那么一定他们的密码hash也一定相同。我们可以通过让每一个hash随机化，同一个密码hash两次，得到的不同的hash来避免这种攻击。

具体的操作就是给密码加一个随即的前缀或者后缀，然后再进行hash。这个随即的后缀或者前缀成为"盐"。正如上面给出的例子一样，通过加盐，相同的密码每次hash都是完全不一样的字符串了。检查用户输入的密码是否正确的时候，我们也还需要这个盐，所以盐一般都是跟hash一起保存在数据库里，或者作为hash字符串的一部分。

盐不需要保密，只要盐是随机的话，查表，彩虹表都会失效。因为攻击者无法事先知道盐是什么，也就没有办法预先计算出查询表和彩虹表。如果每个用户都是使用了不同的盐，那么反向查表攻击也没法成功。


### 密码破解的利器——彩虹表 (rainbow table) 

如何存储密码才是安全的？
彩虹表不是 密码-->明文 的简单存储
彩虹表的前身--预先计算的散列链
彩虹表
为什么加盐哈希可以抵御彩虹表
如何存储密码才是安全的？
密码存储有几种方式: 

直接存储密码明文m
存储密码明文的哈希值hash(m)
存储密码明文的加盐哈希 hash(m+salt)，这里的salt可以是用户名，手机号等，但必须保证每个用户的salt都不一样才是安全的。
如果数据库被入侵。
第一方式，明文存储，无安全性可言。
第二种方式，虽然是入侵者得到的是hash值，但由于彩虹表的存在，也很容易批量还原出密码明文来。
只有第三种方式才是相对安全的。

彩虹表不是 密码-->明文 的简单存储
要从c=hash(m)逆向得到原始明文m，有三种办法: 

暴力破解法: 时间成本太高。
字典法: 提前构建一个“明文->密文”对应关系的一个大型数据库，破解时通过密文直接反查明文。但存储一个这样的数据库，空间成本是惊人的。
构建彩虹表: 在字典法的基础上改进，以时间换空间。是现在破解哈希常用的办法。
彩虹表的前身--预先计算的散列链
既然存储所有的明文密码对需要的空间太大，密码学家们想出了一种以计算时间降低存储空间的办法: “预计算的哈希链集” (Precomputed hash chains) 。
这是一条k=2哈希链: 
哈希链

H函数就是要破解的哈希函数。
约简函数 (reduction function) R函数是构建这条链的时候定义的一个函数: 它的值域和定义域与H函数相反。通过该函数可以将哈希值约简为一个与原文相同格式的值。
这条链是这样生成的: 
随机选择一个明文aaaaaa
对其求哈希得到281DAF40
R(281DAF40) 得到另外一个明文sgfnyd。
继续重复2,3步骤
存储的时候，不需要存储所有的节点，只需要存储每条链的头尾节点 (这里是aaaaaa和kiebgt) 
以大量的随机明文作为起节点，通过上述步骤计算出哈希链并将终节点进行储存，可得到一张哈希链集。

预计算的哈希链集的使用
要破解一个hash值，

假设其刚好是920ECF10: 首先对其进行一次R运算，得到kiebgt，然后发现刚好命中了哈希链集中的 (aaaaaa,kiebgt) 链条。可以确定其极大概率在这个链条中。于是从aaaaaa开始重复哈希链的计算过程，发现sgfnyd的哈希结果刚好是920ECF10,于是破解成功。
密文不是“920ECF10”而是“281DAF40”: 第一次R运算后的结果并未在末节点中找到，则再重复一次H运算+R运算，这时又得到了末节点中的值“kiebgt”。于是再从头开始运算，可知aaaaaa刚好可哈希值为281DAF40。
如是重复了k (=2) 次之后，仍然没有在末节点中找到对应的值，则破解失败。
预计算的哈希链集的意义
对于一个长度为k的预计算的哈希链集，每次破解计算次数不超过k，因此比暴力破解大大节约时间。
每条链只保存起节点和末节点，储存空间只需约1/k，因而大大节约了空间。

R函数的问题
要发挥预计算的哈希链集的左右，需要一个分布均匀的R函数。当出现碰撞时，就会出现下面这种情况
111 --H--> EDEDED --R--> 222 --H--> FEDEFE --R--> 333 --H--> FEFEDC --R--> 444
454 --H--> FEDECE --R--> 333 --H--> FEFEDC --R--> 444 -H--> FEGEDC --R--> 555

两条链出现了重叠。这两条哈希链能解密的明文数量就远小于理论上的明文数2×k。由于集合只保存链条的首末节点，因此这样的重复链条并不能被迅速地发现。

彩虹表
彩虹表的出现，针对性的解决了R函数导致的链重叠问题: 
它在各步的运算中，并不使用统一的R函数，而是分别使用R1…Rk共k个不同的R函数 (下划线表示下标) 。
彩虹表

这样一来，及时发生碰撞，通常会是下面的情况: 
111 --H--> EDEDED --R1--> 222 --H--> FEDEFE --R2--> 333 --H--> FEFEDC --R3--> 444
454 --H--> FEDECE --R1--> 333 --H--> FEFEDC --R2--> 474 -H--> FERFDC --R3--> 909
即使在极端情况下，两个链条同一序列位置上发生碰撞，导致后续链条完全一致，这样的链条也会因为末节点相同而检测出来，可以丢弃其中一条而不浪费存储空间。
彩虹表的使用
彩虹表的使用比哈希链集稍微麻烦一些。

首先，假设要破解的密文位于某一链条的k-1位置处，对其进行Rk运算，看是否能够在末节点中找到对应的值。如果找到，则可以如前所述，使用起节点验证其正确性。
否则，继续假设密文位于k-2位置处，这时就需要进行Rk-1、H、Rk两步运算，然后在末节点中查找结果。
如是反复，最不利条件下需要将密文进行完整的R1、H、…Rk运算后，才能得知密文是否存在于彩虹表之中。
彩虹表中时间、空间的平衡
对于哈希链集，最大计算次数为k，平均计算次数为k/2
彩虹表的最大计算次数为1+2+3+……k = k(k-1)/2，平均计算次数为[(k+2) * (k +1)]/6。
可见，要解相同个数的明文，彩虹表的代价会高于哈希链集。

无论哈希链集还是彩虹表: 
当k越大时，破解时间就越长，但彩虹表所占用的空间就越小；
相反，k越小时，彩虹表本身就越大，相应的破解时间就越短。

常见的彩虹表和R函数举例
1) 常见的彩虹表: http://project-rainbowcrack.com/table.htm
2) R函数举例: 假设明文为5位数字，则R函数是取哈希值中前5个数字。参见https://crypto.stackexchange.com/questions/5900/example-rainbow-table-generation

为什么加盐哈希可以抵御彩虹表
彩虹表在生成的过程中，针对的是特定的函数H，H如果发生了改变，则已有的彩虹表数据就完全无法使用。
如果每个用户都用一个不同的盐值，那么每个用户的H函数都不同，则必须要为每个用户都生成一个不同的彩虹表。大大提高了破解难度。

作者: 风再起时ME
链接: https://www.jianshu.com/p/732d9d960411
来源: 简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


---

https://www.zhihu.com/question/19790488
>https://www.tomczhen.com/2016/10/10/hashing-security/
>https://www.ssl.com/zh-CN/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E5%AF%86%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/
>https://www.tomczhen.com/2016/10/10/hashing-security/