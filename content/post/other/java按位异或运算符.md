---
title: Java按位异或运算符
author: "-"
date: 2011-12-28T05:48:39+00:00
url: /?p=2045
categories:
  - Java
tags:$
  - reprint
---
## Java按位异或运算符
按位异或运算符

两个操作数中，如果两个相应位相同，则结果为0，否则为1
  
即: 
  
0^0=0, 1^0=1, 0^1=1, 1^1=0
  
例如: 
  
00101010^00010111=00111101
  
1)如果需使用一个整数的某些特定的位翻转，可使用另一个
  
相应位为1的操作数与原来的整数进行按位异或操作实现。
  
下面的例子对整数变量 ii的第四位翻转
  
int revertFouth=ii^8;
  
其余位则没有变化
  
2) 通过按位异或运算可以实现两个值的交换。而不使用临
  
时变量。例如交换两个整数a,b的值可通过下列语句实现: 
  
int a=15,b=24;
  
//a的最右边8位为00001111，b的最右边8位为00011000
  
//a和b其余位为0，下同
  
a=a^b; //a的最右边8位为00010111，a=23
  
b=b^a; //b的最右边8位为00001111，b=15
  
a=a^b; //a的最右边8位为00011000，a=24
  
*位逻辑运算表达式返回两个操作数中数据长度较长的数据
  
类型
  
其中较小的左侧将被填满，若为整数，则填满0，
  
若为负数，则左侧填满1

首先复习一下异或运算 (^) 的性质: 它满足交换律、结合律。
  
此处有一个经典的运用: 现在有一万 (1-10000) 的个数，从中拿掉一个数，问怎么才能找出拿掉的数？

设 最初的数组是 A，
  
拿掉 x 之后的数组是 B，
  
xor() 是对数组内所有元素做异或，则有: 
  
xor(A) == xor(B) ^ x
  
Fake代码
  
xor(A) == xor(B) ^ x

所以: 
  
xor(B) ^ xor(A) == xor(B) ^ xor(B) ^ x == 0 ^ x == x
  
Fake代码
  
xor(B) ^ xor(A) == xor(B) ^ xor(B) ^ x == 0 ^ x == x

结论: 
  
A 和 B 两个数组共 19999 个数，全部用来做异或，结果就是去掉的那个数 x。

 (注: 设 A = {a1, a2, a3, .... a10000}， 则 array_xor(A) = a1 ^ a2 ^ a3 ^ ... ^ a10000 ) 