---
title: Java正则表达式
author: wiloon
type: post
date: 2012-08-19T03:08:26+00:00
url: /?p=3909
categories:
  - Java
tags:
  - Regex

---
3位数字 d{3}

&nbsp;

众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生，而这些情况有时又比较复杂，如果用纯编码方式解决，往往会浪费程序员的时间及精力。因此，学习及使用正则表达式，便成了解决这一矛盾的主要手段。

<div id="article_content">
  <div>
    大 家都知道，正则表达式是一种可以用于模式匹配和替换的规范，一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它 用以描述在查找文字主体时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。<br /> 自从jdk1.4推出java.util.regex包，就为我们提供了很好的JAVA正则表达式应用平台。因为正则表达式是一个很庞杂的体系，所以我仅例举些入门的概念，更多的请参阅相关书籍及自行摸索。</p> 
    
    <p>
      // 反斜杠<br /> /t 间隔 (&#8216;/u0009&#8217;)<br /> /n 换行 (&#8216;/u000A&#8217;)<br /> /r 回车 (&#8216;/u000D&#8217;)<br /> /d 数字 等价于[0-9]<br /> /D 非数字 等价于[^0-9]<br /> /s 空白符号 [/t/n/x0B/f/r]<br /> /S 非空白符号 [^/t/n/x0B/f/r]<br /> /w 单独字符 [a-zA-Z_0-9]<br /> /W 非单独字符 [^a-zA-Z_0-9]<br /> /f 换页符<br /> /e Escape<br /> /b 一个单词的边界<br /> /B 一个非单词的边界<br /> /G 前一个匹配的结束
    </p>
    
    <p>
      ^为限制开头<br /> ^java     条件限制为以Java为开头字符<br /> $为限制结尾<br /> java$     条件限制为以java为结尾字符<br /> .  条件限制除/n以外任意一个单独字符<br /> java..     条件限制为java后除换行外任意两个字符
    </p>
    
    <p>
      加入特定限制条件「[]」<br /> [a-z]     条件限制在小写a to z范围中一个字符<br /> [A-Z]     条件限制在大写A to Z范围中一个字符<br /> [a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符<br /> [0-9]     条件限制在小写0 to 9范围中一个字符<br /> [0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符<br /> [0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集)
    </p>
    
    <p>
      []中加入^后加再次限制条件「[^]」<br /> [^a-z]     条件限制在非小写a to z范围中一个字符<br /> [^A-Z]     条件限制在非大写A to Z范围中一个字符<br /> [^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符<br /> [^0-9]     条件限制在非小写0 to 9范围中一个字符<br /> [^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符<br /> [^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集)
    </p>
    
    <p>
      在限制条件为特定字符出现0次以上时，可以使用「*」<br /> J*     0个以上J<br /> .*     0个以上任意字符<br /> J.*D     J与D之间0个以上任意字符
    </p>
    
    <p>
      在限制条件为特定字符出现1次以上时，可以使用「+」<br /> J+     1个以上J<br /> .+     1个以上任意字符<br /> J.+D     J与D之间1个以上任意字符
    </p>
    
    <p>
      在限制条件为特定字符出现有0或1次以上时，可以使用「?」<br /> JA?     J或者JA出现
    </p>
    
    <p>
      限制为连续出现指定次数字符「{a}」<br /> J{2}     JJ<br /> J{3}     JJJ<br /> 文字a个以上，并且「{a,}」<br /> J{3,}     JJJ,JJJJ,JJJJJ,???(3次以上J并存)<br /> 文字个以上，b个以下「{a,b}」<br /> J{3,5}     JJJ或JJJJ或JJJJJ<br /> 两者取一「|」<br /> J|A     J或A<br /> Java|Hello     Java或Hello
    </p>
    
    <p>
      「()」中规定一个组合类型<br /> 比如，我查询<a href=/&#8221;index.html/&#8221;>index</a>中<a href></a>间的数据，可写作<a.*href=/&#8221;.*/&#8221;>(.+?)</a>
    </p>
    
    <p>
      在使用Pattern.compile函数时，可以加入控制正则表达式的匹配行为的参数：<br /> Pattern Pattern.compile(String regex, int flag)
    </p>
    
    <p>
      flag的取值范围如下：<br /> Pattern.CANON_EQ     当且仅当两个字符的&#8221;正规分解(canonical decomposition)&#8221;都完全相同的情况下，才认定匹配。比如用了这个标志之后，表达式&#8221;a/u030A&#8221;会匹配&#8221;?&#8221;。默认情况下，不考虑&#8221;规 范相等性(canonical equivalence)&#8221;。<br /> Pattern.CASE_INSENSITIVE(?i)     默认情况下，大小写不明感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹 配，只要将UNICODE_CASE与这个标志合起来就行了。<br /> Pattern.COMMENTS(?x)     在这种模式下，匹配时会忽略(正则表达式里的)空格字符(译者注：不是指表达式里的&#8221;//s&#8221;，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。<br /> Pattern.DOTALL(?s)     在这种模式下，表达式&#8217;.&#8217;可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式&#8217;.&#8217;不匹配行的结束符。<br /> Pattern.MULTILINE<br /> (?m)     在这种模式下，&#8217;^&#8217;和&#8217;$&#8217;分别匹配一行的开始和结束。此外，&#8217;^&#8217;仍然匹配字符串的开始，&#8217;$&#8217;也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。<br /> Pattern.UNICODE_CASE<br /> (?u)     在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不明感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。<br /> Pattern.UNIX_LINES(?d)     在这个模式下，只有&#8217;/n&#8217;才被认作一行的中止，并且与&#8217;.&#8217;，&#8217;^&#8217;，以及&#8217;$&#8217;进行匹配。
    </p>
    
    <p>
      抛开空泛的概念，下面写出几个简单的Java正则用例：
    </p>
    
    <p>
      ◆比如，在字符串包含验证时
    </p>
    
    <p>
      //查找以Java开头,任意结尾的字符串<br /> Pattern pattern = Pattern.compile(&#8220;^Java.*&#8221;);<br /> Matcher matcher = pattern.matcher(&#8220;Java不是人&#8221;);<br /> boolean b= matcher.matches();<br /> //当条件满足时，将返回true，否则返回false<br /> System.out.println(b);
    </p>
    
    <p>
      ◆以多条件分割字符串时<br /> Pattern pattern = Pattern.compile(&#8220;[, |]+&#8221;);<br /> String[] strs = pattern.split(&#8220;Java Hello World  Java,Hello,,World|Sun&#8221;);<br /> for (int i=0;i<strs.length;i++) {<br /> System.out.println(strs[i]);<br /> }
    </p>
    
    <p>
      ◆文字替换（首次出现字符）<br /> Pattern pattern = Pattern.compile(&#8220;正则表达式&#8221;);<br /> Matcher matcher = pattern.matcher(&#8220;正则表达式 Hello World,正则表达式 Hello World&#8221;);<br /> //替换第一个符合正则的数据<br /> System.out.println(matcher.replaceFirst(&#8220;Java&#8221;));
    </p>
    
    <p>
      ◆文字替换（全部）<br /> Pattern pattern = Pattern.compile(&#8220;正则表达式&#8221;);<br /> Matcher matcher = pattern.matcher(&#8220;正则表达式 Hello World,正则表达式 Hello World&#8221;);<br /> //替换第一个符合正则的数据<br /> System.out.println(matcher.replaceAll(&#8220;Java&#8221;));
    </p>
    
    <p>
      ◆文字替换（置换字符）<br /> Pattern pattern = Pattern.compile(&#8220;正则表达式&#8221;);<br /> Matcher matcher = pattern.matcher(&#8220;正则表达式 Hello World,正则表达式 Hello World &#8220;);<br /> StringBuffer sbr = new StringBuffer();<br /> while (matcher.find()) {<br /> matcher.appendReplacement(sbr, &#8220;Java&#8221;);<br /> }<br /> matcher.appendTail(sbr);<br /> System.out.println(sbr.toString());
    </p>
    
    <p>
      ◆验证是否为邮箱地址
    </p>
    
    <p>
      String str=&#8221;ceponline@yahoo.com.cn&#8221;;<br /> Pattern pattern = Pattern.compile(&#8220;[//w//.//-]+@([//w//-]+//.)+[//w//-]+&#8221;,Pattern.CASE_INSENSITIVE);<br /> Matcher matcher = pattern.matcher(str);<br /> System.out.println(matcher.matches());
    </p>
    
    <p>
      ◆去除html标记<br /> Pattern pattern = Pattern.compile(&#8220;<.+?>&#8221;, Pattern.DOTALL);<br /> Matcher matcher = pattern.matcher(&#8220;<a href=/&#8221;index.html/&#8221;>主页</a>&#8221;);<br /> String string = matcher.replaceAll(&#8220;&#8221;);<br /> System.out.println(string);
    </p>
    
    <p>
      ◆查找html中对应条件字符串<br /> Pattern pattern = Pattern.compile(&#8220;href=/&#8221;(.+?)/&#8221;&#8221;);<br /> Matcher matcher = pattern.matcher(&#8220;<a href=/&#8221;index.html/&#8221;>主页</a>&#8221;);<br /> if(matcher.find())<br /> System.out.println(matcher.group(1));<br /> }
    </p>
    
    <p>
      ◆截取http://地址<br /> //截取url<br /> Pattern pattern = Pattern.compile(&#8220;(http://|https://){1}[//w//.//-/:]+&#8221;);<br /> Matcher matcher = pattern.matcher(&#8220;dsdsds<http://dsds//gfgffdfd>fdf&#8221;);<br /> StringBuffer buffer = new StringBuffer();<br /> while(matcher.find()){<br /> buffer.append(matcher.group());<br /> buffer.append(&#8220;/r/n&#8221;);<br /> System.out.println(buffer.toString());<br /> }
    </p>
    
    <p>
      ◆替换指定{}中文字
    </p>
    
    <p>
      String str = &#8220;Java目前的发展史是由{0}年-{1}年&#8221;;<br /> String[][] object={new String[]{&#8220;//{0//}&#8221;,&#8221;1995&#8243;},new String[]{&#8220;//{1//}&#8221;,&#8221;2007&#8243;}};<br /> System.out.println(replace(str,object));
    </p>
    
    <p>
      public static String replace(final String sourceString,Object[] object) {<br /> String temp=sourceString;<br /> for(int i=0;i<object.length;i++){<br /> String[] result=(String[])object[i];<br /> Pattern    pattern = Pattern.compile(result[0]);<br /> Matcher matcher = pattern.matcher(temp);<br /> temp=matcher.replaceAll(result[1]);<br /> }<br /> return temp;<br /> }
    </p>
    
    <p>
      ◆以正则条件查询指定目录下文件
    </p>
    
    <p>
      //用于缓存文件列表<br /> private ArrayList files = new ArrayList();<br /> //用于承载文件路径<br /> private String _path;<br /> //用于承载未合并的正则公式<br /> private String _regexp;
    </p>
    
    <p>
      class MyFileFilter implements FileFilter {
    </p>
    
    <p>
      /**<br /> * 匹配文件名称<br /> */<br /> public boolean accept(File file) {<br /> try {<br /> Pattern pattern = Pattern.compile(_regexp);<br /> Matcher match = pattern.matcher(file.getName());<br /> return match.matches();<br /> } catch (Exception e) {<br /> return true;<br /> }<br /> }<br /> }
    </p>
    
    <p>
      /**<br /> * 解析输入流<br /> * @param inputs<br /> */<br /> FilesAnalyze (String path,String regexp){<br /> getFileName(path,regexp);<br /> }
    </p>
    
    <p>
      /**<br /> * 分析文件名并加入files<br /> * @param input<br /> */<br /> private void getFileName(String path,String regexp) {<br /> //目录<br /> _path=path;<br /> _regexp=regexp;<br /> File directory = new File(_path);<br /> File[] filesFile = directory.listFiles(new MyFileFilter());<br /> if (filesFile == null) return;<br /> for (int j = 0; j < filesFile.length; j++) {<br /> files.add(filesFile[j]);<br /> }<br /> return;<br /> }
    </p>
    
    <p>
      /**<br /> * 显示输出信息<br /> * @param out<br /> */<br /> public void print (PrintStream out) {<br /> Iterator elements = files.iterator();<br /> while (elements.hasNext()) {<br /> File file=(File) elements.next();<br /> out.println(file.getPath());<br /> }<br /> }
    </p>
    
    <p>
      public static void output(String path,String regexp) {
    </p>
    
    <p>
      FilesAnalyze fileGroup1 = new FilesAnalyze(path,regexp);<br /> fileGroup1.print(System.out);<br /> }
    </p>
    
    <p>
      public static void main (String[] args) {<br /> output(&#8220;C://&#8221;,&#8221;[A-z|.]*&#8221;);<br /> }
    </p>
    
    <p>
      Java正则的功用还有很多，事实上只要是字符处理，就没有正则做不到的事情存在。（当然，正则解释时较耗时间就是了|||……）
    </p>
    
    <p>
      &nbsp;
    </p>
    
    <p>
      http://blog.csdn.net/kdnuggets/article/details/2526588
    </p>
  </div>
</div>