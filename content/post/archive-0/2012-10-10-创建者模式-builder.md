---
title: 创建者模式 Builder
author: wiloon
type: post
date: 2012-10-10T04:23:22+00:00
url: /?p=4421
categories:
  - Java
tags:
  - DesignPattern

---
对于Builder模式很简单，但是一直想不明白为什么要这么设计，为什么要向builder要Product而不是向知道建造过程的Director要。刚才google到一篇文章，总算清楚了。在这里转贴一下这位richardluo的比喻。

简单地说，就好象我要一座房子住，可是我不知道怎么盖（简单的砌墙，层次较低），也不知道怎么样设计（建几个房间，几个门好看，层次较高），于是我需要找一帮民工，他们会砌墙，还得找个设计师，他知道怎么设计，我还要确保民工听设计师的领导，而设计师本身也不干活，光是下命令，这里砌一堵墙，这里砌一扇门，这样民工开始建设，最后，我可以向民工要房子了。在这个过程中，设计师是什么也没有，除了他在脑子里的设计和命令，所以要房子也是跟民工要，记住了！

以下是richardluo的代码，我根据他的思路加上了相应的注释。

1，定义工人接口，就是能够完成建造房子任务的人的通用要求。

[java]

// 工人接口，定义了各个工人所要进行的工所作。他们负责进行具体部件如窗户，地板的建造。

// 同时因为房子是民工建的，因此建设完成后由他把房子递交回房主

public interface Builder {

public void makeWindow();

public void makeFloor();

public Room getRoom();

}

2，定义设计师，他的职责是指挥房主指派给他的工人按照自己的设计意图建造房子。

[java]

// 设计师。他知道房子应该怎么设计，但他不会自己去建造，而是指挥民工去建造。

public class Designer {

// 指挥民工进行工作

public void order(Builder builder) {

builder.makeWindow();

builder.makeFloor();

}

}

[/java]

3，民工，他负责具体事物的实施。

[java]

// 民工。负责进行具体部件如窗户，地板的建造。

//同时因为房子是民工建的，因此建设完成后由他把房子递交回房主

public class Mingong implements Builder {

private String window="";

private String floor="";

public void makeWindow() {

window=new String("window");

}

public void makeFloor(){

floor=new String("floor");

}

// 回交房子给房主

public Room getRoom() {

if((!window.equals(""))&&(!floor.equals(""))) {

System.out.println("room ready!");

return new Room();

}

else return null;

}

}

[/java]

4，房主，就是雇人，收房。

[java]

// 房主。房主的任务就是聘请一个民工，一个设计师，同时把民工给设计师指挥，督促设计师开展工作。最后从民工手上收房。

public class Client {

public static void main(String[] args) {

Builder mingong = new Mingong();

Designer designer = new Designer();

designer.order(mingong);

mingong.getRoom();

}

}

[/java]

好了，我觉得这样大概能说明白了。不知各位觉得如何呢？或者有更好的应用场景解释，敬请赐教。

<span style="font-family: 'Times New Roman';"> [GOF95]</span>中，<span style="font-family: 'Times New Roman';">Builder</span>模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

Builder模式和AbstractFactory模式在功能上很相似，因为都是用来创建大的复杂的对象，它们的区别是：Builder模式强调的是一步步创建对象，并通过相同的创建过程可以获得不同的结果对象，一般来说Builder模式中对象不是直接返回的。而在AbstractFactory模式中对象是直接返回的，AbstractFactory模式强调的是为创建多个相互依赖的对象提供一个同一的接口。

[java]

class Room {

}

abstract class Builder {
   
protected String window = "";

protected String floor = "";

public void prepareWater() {
   
}

public void prepareElectricity() {
   
}
   
public void prepareRoad() {
   
}
   
public void makeWindow() {
   
}
   
public void makeFloor() {
   
}
   
public abstract Room getRoom();
   
public void makeGarden() {
   
}
  
}

// Designer。他知道房子应该怎么设计，但他不会自己去建造，而是指挥民工去建造。
  
abstract class Designer {
   
Builder builder;

public Designer(Builder builder) {
   
this.builder = builder;
   
}

public void preparationWorks() {
   
builder.prepareWater();
   
builder.prepareElectricity();
   
builder.prepareRoad();
   
}
   
public abstract void construct();
  
}

class ApartmentDesigner extends Designer {

public ApartmentDesigner(Builder builder) {
   
super(builder);
   
}

// 指挥工人进行工作
   
public void construct() {
   
preparationWorks();
   
builder.makeWindow();

builder.makeFloor();

}

}

class HouseDesigner extends Designer {

public HouseDesigner(Builder builder) {
   
super(builder);
   
}

// 指挥工人进行工作
   
public void construct() {
   
preparationWorks();
   
builder.makeWindow();

builder.makeFloor();
   
builder.makeGarden();
   
}
  
}

// 建筑工人。负责进行具体部件如窗户，地板的建造.
  
//同时因为房子是工人建的，因此建设完成后由他把房子递交回房主.
  
class ApartmentBuilder extends Builder {
   
@Override
   
public void prepareWater() {
   
}

@Override
   
public void prepareElectricity() {
   
}

@Override
   
public void prepareRoad() {
   
}

public void makeWindow() {

window = new String("apartment window");

}

public void makeFloor() {

floor = new String("apartment floor");

}

// 回交房子给房主

public Room getRoom() {

if ((!window.equals("")) && (!floor.equals(""))) {

System.out.println("room ready!");

return new Room();

} else return null;

}
  
}

class HouseBuilder extends Builder {

@Override
   
public Room getRoom() {
   
return null;
   
}

public void makeWindow() {

window = new String("house window");

}

public void makeFloor() {

floor = new String("house floor");

}

@Override
   
public void makeGarden() {
   
//To change body of implemented methods use File | Settings | File Templates.
   
}
  
}

// 房主。房主的任务就是聘请一个工人，一个设计师，同时把工人给设计师指挥，督促设计师开展工作。最后从工人手上收房。
  
public class BuilderPatternClient {

public static void main(String[] args) {

Builder builder = new ApartmentBuilder();

Designer designer = new ApartmentDesigner(builder);

designer.construct();

builder.getRoom();

builder = new HouseBuilder();
   
designer = new HouseDesigner(builder);
   
designer.construct();
   
builder.getRoom();
   
}
  
}

[/java]

<http://blog.csdn.net/surprisesdu/article/details/621046>

<http://smartfool.iteye.com/blog/71175>