---
title: Android多线程及异步处理问题
author: wiloon
type: post
date: 2012-07-08T05:10:41+00:00
url: /?p=3785
categories:
  - Uncategorized

---
<div>
</div>

<div>
  <div>
    1、问题提出
  </div>
  
  <div>
    1）为何需要多线程？
  </div>
  
  <div>
    2）多线程如何实现？
  </div>
  
  <div>
    3）多线程机制的核心是啥？
  </div>
  
  <div>
    4）到底有多少种实现方式？
  </div>
  
  <div>
  </div>
  
  <div>
    2、问题分析
  </div>
  
  <div>
    1）究其为啥需要多线程的本质就是<strong>异步处理</strong>，直观一点说就是不要让用户感觉到“很卡”。
  </div>
  
  <div>
    eg:你点击按钮下载一首歌，接着该按钮一直处于按下状态，那么用户体验就很差。
  </div>
  
  <div>
  </div>
  
  <div>
    2）多线程实现方式implements Runnable 或 extends Thread
  </div>
  
  <div>
  </div>
  
  <div>
    3）多线程核心机制是Handler
  </div>
  
  <div>
  </div>
  
  <div>
    4）提供如下几种实现方式
  </div>
  
  <div>
    <span>&#8212;-1&#8212;&#8211;Handler</span>
  </div>
  
  <div>
    ————————————说明1
  </div>
  
  <div>
    创建一个Handler时一定要关联一个Looper实例，默认构造方法Handler()，它是关联当前Thread的Looper。
  </div>
  
  <div>
    eg:
  </div>
  
  <div>
    我们在UI Thread中创建一个Handler,那么此时就关联了UI Thread的Looper！
  </div>
  
  <div>
    这一点从源码中可以看出！
  </div>
  
  <div>
    精简代码如下：
  </div>
  
  <div>
    public Handler() {
  </div>
  
  <div>
            mLooper = Looper.myLooper();
  </div>
  
  <div>
    //当前线程的Looper，在Activity创建时，UI线程已经创建了Looper对象
  </div>
  
  <div>
    //在Handler中机制中Looper是最为核心的，它一直处于循环读MessageQueue，有
  </div>
  
  <div>
    //要处理的Message就将Message发送给当前的Handler实例来处理
  </div>
  
  <div>
    if (mLooper == null) {<br /> throw new RuntimeException(<br /> &#8220;Can&#8217;t create handler inside thread that has not called Looper.prepare()&#8221;);<br /> }
  </div>
  
  <div>
    //从以上可以看出，一个Handler实例必须关联一个Looper对象，否则出错
  </div>
  
  <div>
    mQueue = mLooper.mQueue;
  </div>
  
  <div>
    //Handler的MessageQueue，它是FIFO的吗？不是！我感觉应该是按时间先后排列
  </div>
  
  <div>
    //的！Message与MessageQueue到底是啥关系？感兴趣可以研究一下源码！
  </div>
  
  <div>
    mCallback = null;<br /> }
  </div>
  
  <div>
  </div>
  
  <div>
  </div>
  
  <div>
    在创建一个Handler的时候也可以指定Looper，此时的Looper对象，可以是当前线程的也可以是其它线程的！
  </div>
  
  <div>
    Handler只是处理它所关联的Looper中的MessageQueue中的Message，至于它哪个线程的Looper，Handler并不是很关心！
  </div>
  
  <div>
    eg:
  </div>
  
  <div>
    我们在UI线程中创建了Handler实例，此时传进Worker线程的Looper，此时依然可以进行业务操作！
  </div>
  
  <div>
    eg:
  </div>
  
  <div>
    &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;创建工作者线程
  </div>
  
  <div>
    private static final class Worker implements Runnable<br /> {<br /> private static final Object mLock = new Object() ;<br /> private Looper mLooper ;</p> 
    
    <p>
      public Worker(String name)<br /> {<br /> final Thread thread = new Thread(null,this,name) ;<br /> thread.setPriority(Thread.MIN_PRIORITY) ;<br /> thread.start() ;
    </p>
    
    <p>
      synchronized(mLock)<br /> {<br /> while(mLooper == null)<br /> {<br /> try<br /> {
    </p>
  </div>
  
  <div>
          mLock.wait() ;
  </div>
  
  <div>
         }<br /> catch (InterruptedException e)<br /> {<br /> e.printStackTrace();<br /> }<br /> }<br /> }<br /> }</p> 
    
    <p>
      @Override<br /> public void run() {<br /> synchronized(mLock)<br /> {<br /> //该方法只能执行一次,一个Thread只能关联一个Looper<br /> Looper.prepare() ;
    </p>
  </div>
  
  <div>
           mLooper = Looper.myLooper() ;
  </div>
  
  <div>
           mLock.notifyAll() ;<br /> }
  </div>
  
  <div>
         Looper.loop() ;<br /> }</p> 
    
    <p>
      public Looper getLooper()<br /> {<br /> return mLooper ;<br /> }
    </p>
    
    <p>
      public void quit()<br /> {<br /> mLooper.quit() ;<br /> }<br /> }
    </p>
  </div>
  
  <div>
    我们可以在UI线程中创建一个Handler同时传入Worker的Looper
  </div>
  
  <div>
    eg:
  </div>
  
  <div>
    &#8212;&#8212;&#8212;&#8212;&#8212;-定义自己的Handler
  </div>
  
  <div>
    private final class MyHandler extends Handler<br /> {<br /> private long id ;</p> 
    
    <p>
      public MyHandler(Looper looper)<br /> {<br /> super(looper) ;<br /> }
    </p>
    
    <p>
      @Override<br /> public void handleMessage(Message msg) {<br /> switch(msg.what)<br /> {<br /> case 100 :
    </p>
  </div>
  
  <div>
        mTv.setText(&#8220;&#8221; + id) ;<br /> break ;<br /> }<br /> }<br /> }
  </div>
  
  <div>
  </div>
  
  <div>
    &#8212;&#8212;&#8212;在Activity中创建Handler
  </div>
  
  <div>
    this.mWorker = new Worker(&#8220;workerThread&#8221;) ;<br /> this.mMyHandler = new MyHandler(this.mWorker.getLooper()) ;
  </div>
  
  <div>
  </div>
  
  <div>
    &#8212;&#8212;&#8212;创建Message
  </div>
  
  <div>
    final Message msg = this.mMyHandler.obtainMessage(100);
  </div>
  
  <div>
    msg.put(&#8220;test&#8221; , &#8220;test&#8221;) ;
  </div>
  
  <div>
    msg.sendToTarget() ;
  </div>
  
  <div>
  </div>
  
  <div>
    需要注意的是，每一个Message都必须要有自己的Target即Handler实例！
  </div>
  
  <div>
    源码如下：
  </div>
  
  <div>
    public final Message obtainMessage(int what)<br /> {<br /> return Message.obtain(this, what);<br /> }
  </div>
  
  <div>
  </div>
  
  <div>
    public static Message obtain(Handler h, int what) {<br /> Message m = obtain();<br /> <span><strong>m.target = h</strong></span><span>;//可以看出message关联了当前的Handler</span><br /> m.what = what;
  </div>
  
  <div>
            return m;<br /> }
  </div>
  
  <div>
  </div>
  
  <div>
    以上只是作了一点原理性的说明！
  </div>
  
  <div>
  </div>
  
  <div>
        我们平时使用Handler主要是用来处理多线程的异步交互问题！
  </div>
  
  <div>
        由于Android规定只有UI线程才能更新用户界面和接受用户的按钮及触摸事件！
  </div>
  
  <div>
    那么就必须保证UI线程不可以被阻塞，从而耗时操作必须要开启一个新的线程来处理！
  </div>
  
  <div>
        那么问题就来了，等耗时操作结束以后，如何把最新的数据反馈给用户呢？而我们目前工作Worker线程中，从而不可以进行UI更新。
  </div>
  
  <div>
        那么怎么办呢？必须要把最新的数据传给UI线程能处理的地方！现在就派到Handler出场了！可Handler到底干了啥呢？简要说明如下：
  </div>
  
  <div>
       Activity所在的UI线程在创建的时候，就关联了Looper和MessageQueue，那么我们又在UI线程里创建了自己的Handler，那么Handler是属于UI线程的，从而它是可以和UI线程交互的！
  </div>
  
  <div>
        UI线程的Looper一直在进行Loop操作MessageQueue读取符合要求的Message给属于它的target即Handler来处理！所以啊，我们只要在Worker线程中将最新的数据放到Handler所关联的Looper的MessageQueue中，然而Looper一直在loop操作，一旦有符合要求的Message，就第一时间将Message交给该Message的target即Handler来处理！所以啊，我们在创建Message的时候就应该指定它的target即Handler！
  </div>
  
  <div>
      但我们也可以，new Message() &#8212; > mHandler.sendMessage(msg) ;这是特例！
  </div>
  
  <div>
      如果我们通过obtainMessage()方法获取Message对象，此时Handler就会自动设置Message的target。可以看源码！
  </div>
  
  <div>
  </div>
  
  <div>
    简单一点说就是：
  </div>
  
  <div>
    UI线程或Worker线程提供MessageQueue，Handler向其中填Message，Looper从其中读Message，然后交由Message自己的target即Handler来处理！！最终被从属于UI线程的Handler的handlMessag(Message msg)方法被调用！！
  </div>
  
  <div>
  </div>
  
  <div>
    这就是Android多线程异步处理最为核心的地方！！
  </div>
  
  <div>
    有点罗嗦啊！！
  </div>
  
  <div>
  </div>
  
  <div>
    *******************************************************************
  </div>
  
  <div>
    在UI线程中创建Handler[一般继承HandleMessage(Message msg)]
  </div>
  
  <div>
                                               |
  </div>
  
  <div>
                                               |
  </div>
  
  <div>
                Looper可以属于UI线程或Worker线程
  </div>
  
  <div>
                                               |
  </div>
  
  <div>
                                               |
  </div>
  
  <div>
    从属于Looper的MessgeQueue，Looper一直在loop()操作,在loop()中执行msg.target.dispatchMessage(msg);调用Handler的handleMessage(Message msg)
  </div>
  
  <div>
                                               |
  </div>
  
  <div>
                                               |
  </div>
  
  <div>
    在 Worker线程中获取Message，然后通过Handler传入MessageQueue
  </div>
  
  <div>
    *******************************************************************
  </div>
  
  <div>
  </div>
  
  <div>
    &#8212;&#8212;&#8212;&#8212;&#8212;&#8211;在创建一个Looper时，就创建了从属于该Looper的MessageQueue
  </div>
  
  <div>
     private Looper() {<br /> mQueue = new MessageQueue();<br /> mRun = true;<br /> mThread = Thread.currentThread();<br /> }
  </div>
  
  <div>
  </div>
  
  <div>
    <span>&#8212;-2&#8212;&#8211;View</span>
  </div>
  
  <div>
    post(Runnable action)
  </div>
  
  <div>
    postDelay(Runnable action , long miliseconds)
  </div>
  
  <div>
  </div>
  
  <div>
    <span>&#8212;&#8211;3&#8212;&#8211;Activity</span>
  </div>
  
  <div>
    runOnUiThread(Runnable action)
  </div>
  
  <div>
    该方法实现很简单：
  </div>
  
  <div>
    public final void runOnUiThread(Runnable action) {<br /> if (Thread.currentThread() != mUiThread) {
  </div>
  
  <div>
                 //如果当前线程不是UI线程<br /> mHandler.post(action);<br /> } else {<br /> action.run();<br /> }<br /> }
  </div>
  
  <div>
    其中：
  </div>
  
  <div>
     mUiThread = Thread.currentThread() ;<br /> mHandler = new Handler()    
  </div>
  
  <div>
  </div>
  
  <div>
    <span>&#8212;&#8211;4&#8212;&#8211;AsyncTask<Params,Progress,Result></span>
  </div>
  
  <div>
    Params,Progress,Result都是数据类型，
  </div>
  
  <div>
    Params要处理的数据的类型
  </div>
  
  <div>
    Progress处理进度的类型
  </div>
  
  <div>
    Result处理后返回的结果
  </div>
  
  <div>
  </div>
  
  <div>
    它是一个异步处理的简单方法！
  </div>
  
  <div>
    方法的执行顺序：
  </div>
  
  <div>
    1）
  </div>
  
  <div>
    onPreExecute() &#8211;在UI线程中执行，作一些初始化操作
  </div>
  
  <div>
  </div>
  
  <div>
    2）
  </div>
  
  <div>
    doInBackground(Params&#8230; params) &#8211;在Worker线程中执行，进行耗时的后台处理，在该方法中可以调用publishProgress(Progress progress) 进行进度处理
  </div>
  
  <div>
  </div>
  
  <div>
    3）
  </div>
  
  <div>
    onProgressUpdate(Progress progress) &#8211;在UI线程中执行，进行进度实时处理
  </div>
  
  <div>
  </div>
  
  <div>
    4）onPostExecute(Result result) &#8211;在UI线程中执行， 在doInBackground(Params &#8230; params)返回后调用
  </div>
  
  <div>
  </div>
  
  <div>
    5）
  </div>
  
  <div>
    onCancelled() &#8211;在UI线程中执行，在AsyncTask实例调用cancle(true)方法后执行，作一些清理操作
  </div>
  
  <div>
  </div>
  
  <div>
    <span>几点注意：</span>
  </div>
  
  <div>
    AsyncTask必须在UI线程中创建，
  </div>
  
  <div>
    asyncTask.execute(Params&#8230; params) ;在UI线程中执行，且只能执行一次
  </div>
  
  <div>
    要想再次调用execute(Params&#8230; params)，必须重新创建AsyncTask对象
  </div>
  
  <div>
  </div>
  
  <div>
    <span>后3种方法本质上都是利用Handler来实现的！</span>
  </div>
  
  <div>
  </div>
  
  <div>
    3、一点说明
  </div>
  
  <div>
    1）具体使用还是要自己去摸索！只作抛砖吧！
  </div>
  
  <div>
    2）一些使用的注意之处可以参看API Reference！
  </div>
  
  <div>
    2）最好是跟踪分析一下源码！
  </div>
  
  <p>
    本文出自 “<a href="http://myqdroid.blog.51cto.com/">苗运齐的博客</a>” 博客，请务必保留此出处<a href="http://myqdroid.blog.51cto.com/2057579/392157">http://myqdroid.blog.51cto.com/2057579/392157</a>
  </p>
</div>