---
title: System V IPC
author: wiloon
type: post
date: 2012-02-28T13:12:53+00:00
url: /?p=2481
categories:
  - Linux

---
IPC(Inter-Process Communication)是共享"命名管道"的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。
  
System V， 曾经也被称为 AT&T System V，是Unix操作系统众多版本中的一支。它最初由 AT&T 开发，在1983年第一次发布。一共发行了4个 System V 的主要版本：版本1、2、3 和 4。System V Release 4，或者称为SVR4，是最成功的版本，成为一些UNIX共同特性的源头，例如 "SysV 初始化脚本" （/etc/init.d），用来控制系统启动和关闭，System V Interface Definition (SVID) 是一个System V 如何工作的标准定义。 　　AT&T 出售运行System V的专有硬件，但许多（或许是大多数）客户在其上运行一个转售的版本，这个版本基于 AT&T 的实现说明。流行的SysV 衍生版本包括 Dell SVR4 和 Bull SVR4。当今广泛使用的 System V 版本是 SCO OpenServer，基于 System V Release 3，以及SUN Solaris 和 SCO UnixWare，都基于 System V Release 4。 　　System V 是 AT&T 的第一个商业UNIX版本（UNIX System III）的加强。传统上，System V 被看作是两种UNIX"风味"之一（另一个是 BSD）。然而，随着一些并不基于这两者代码的UNIX实现的出现，例如 Linux 和 QNX， 这一归纳不再准确，但不论如何，像POSIX这样的标准化努力一直在试图减少各种实现之间的不同。

7.3 System V 的IPC机制

为了提供与其它系统的兼容性，Linux也支持三种system Ⅴ的进程间通信机制：消息、信号量(semaphores)和共享内存，Linux对这些机制的实施大同小异。我们把信号量、消息和共享内存统称 System V IPC的对象，每一个对象都具有同样类型的接口，即系统调用。就像每个文件都有一个打开文件号一样，每个对象也都有唯一的识别号，进程可以通过系统调用传 递的识别号来存取这些对象，与文件的存取一样，对这些对象的存取也要验证存取权限，System V IPC可以通过系统调用对对象的创建者设置这些对象的存取权限。

在Linux内核中，System V IPC的所有对象有一个公共的数据结构pc_perm结构，它是IPC对象的权限描述，在linux/ipc.h中定义如下：

struct ipc_perm
  
{
  
key_t key; /\* 键 \*/
  
ushort uid; /\* 对象拥有者对应进程的有效用户识别号和有效组识别号 \*/
  
ushort gid;
  
ushort cuid; /\* 对象创建者对应进程的有效用户识别号和有效组识别号 \*/
  
ushort cgid;
  
ushort mode; /\* 存取模式 \*/
  
ushort seq; /\* 序列号 \*/
  
};

在这个结构中，要进一步说明的是键(key)。键和识别号指的是不同的东西。系统支持两种键：公有和私有。如果键是公有的，则系统中所有的进程通过权限检 查后，均可以找到System V IPC 对象的识别号。如果键是公有的，则键值为0，说明每个进程都可以用键值0建立一个专供其私用的对象。注意，对System V IPC对象的引用是通过识别号而不是通过键，从后面的系统调用中可了解这一点。

7.3.1信号量

信号量及信号量上的操作是E.W.Dijkstra 在1965年提出的一种解决同步、互斥问题的较通用的方法，并在很多操作系统中得以实现， Linux改进并实现了这种机制。

信号量(semaphore )实际是一个整数，它的值由多个进程进行测试(test)和设置(set)。就每个进程所关心的测试和设置操作而言，这两个操作是不可中断的，或称"原 子"操作，即一旦开始直到两个操作全部完成。测试和设置操作的结果是：信号量的当前值和设置值相加，其和或者是正或者为负。根据测试和设置操作的结果，一 个进程可能必须睡眠，直到有另一个进程改变信号量的值。

信号量可用来实现所谓的"临界区"的互斥使用，临界区指同一时刻只能有一个进程执行其中代码的代码段。为了进一步理解信号量的使用，下面我们举例说明。

假设你有很多相互协作的进程，它们正在读或写一个数据文件中的记录。你可能希望严格协调对这个文件的存取，于是你使用初始值为1的信号量，在这个信号量上 实施两个操作，首先测试并且给信号量的值减1，然后测试并给信号量的值加1。当第一个进程存取文件时，它把信号量的值减1，并获得成功，信号量的值现在变 为0，这个进程可以继续执行并存取数据文件。但是，如果另外一个进程也希望存取这个文件，那么它也把信号量的值减1，结果是不能存取这个文件，因为信号量 的值变为-1。这个进程将被挂起，直到第一个进程完成对数据文件的存取。当第一个进程完成对数据文件的存取，它将增加信号量的值，使它重新变为1，现在， 等待的进程被唤醒，它对信号量的减1操作将获得成功。

上述的进程互斥问题，是针对进程之间要共享一个临界资源而言的，信号量的初值为1。实际上，信号量作为资源计数器，它的初值可以是任何正整数，其初值不一 定为0或1。另外，如果一个进程要先获得两个或多个的共享资源后才能执行的话，那么，相应地也需要多个信号量，而多个进程要分别获得多个临界资源后方能运 行，这就是信号量集合机制，Linux 讨论的就是信号量集合问题。

1. 信号量的数据结构
  
Linux中信号量是通过内核提供的一系列数据结构实现的，这些数据结构存在于内核空间，对它们的分析是充分理解信号量及利用信号量实现进程间通信的基 础，下面先给出信号量的数据结构(存在于include/linux/sem.h中)，其它一些数据结构将在相关的系统调用中介绍。

(1)系统中每个信号量的数据结构(sem)

1)系统中每个信号量的数据结构(sem)
  
struct sem {
  
int semval; /\* 信号量的当前值 \*/
  
int sempid; /\*在信号量上最后一次操作的进程识别号 \*
  
};

2)系统中表示信号量集合(set)的数据结构(semid_ds)
  
struct semid_ds {
  
struct ipc\_perm sem\_perm; /\* IPC权限 \*/
  
long sem_otime; /\* 最后一次对信号量操作(semop)的时间 \*/
  
long sem_ctime; /\* 对这个结构最后一次修改的时间 \*/
  
struct sem \*sem_base; /\* 在信号量数组中指向第一个信号量的指针 */
  
struct sem\_queue \*sem\_pending; /\* 待处理的挂起操作*/
  
struct sem\_queue *\*sem\_pending_last; /\* 最后一个挂起操作 */
  
struct sem_undo \*undo; /\* 在这个数组上的undo 请求 */
  
ushort sem_nsems; /\* 在信号量数组上的信号量号 \*/
  
};

3) 系统中每一信号量集合的队列结构(sem_queue)
  
struct sem_queue {
  
struct sem_queue \* next; /\* 队列中下一个节点 */
  
struct sem_queue *\* prev; /\* 队列中前一个节点, \*(q->prev) == q \*/
  
struct wait_queue \* sleeper; /\* 正在睡眠的进程 */
  
struct sem_undo \* undo; /\* undo 结构*/
  
int pid; /\* 请求进程的进程识别号 \*/
  
int status; /\* 操作的完成状态 \*/
  
struct semid_ds \* sma; /\*有操作的信号量集合数组 */
  
struct sembuf \* sops; /\* 挂起操作的数组 */
  
int nsops; /\* 操作的个数 \*/
  
};

(4)几个主要数据结构之间的关系

从7.3图可以看出，semid\_ds结构的sem\_base指向一个信号量数组，允许操作这些信号量集合的进程可以利用系统调用执行操作。注意，信号量 信号量集合的区别，从上面可以看出，信号量用"sem" 结构描述，而信量集合用"semid_ds"结构描述，实际上，在后面的讨论中，我们以信号量集合为讨论的主要对象。下面我们给出这几个结构之间的关系， 如图7.3所示。

Linux对信号量的这种实现机制，是为了与消息和共享内存的实现机制保持一致，但信号量是这三者中最难理解的，因此我们将结合系统调用做进一步的介绍，通过对系统调用的深入分析，我们可以较清楚地了解内核对信号量的实现机制。

2. 系统调用：semget()

为了创建一个新的信号量集合，或者存取一个已存在的集合，要使用segget()系统调用，其描述如下：

原型: int semget ( key_t key, int nsems, int semflg );
  
返回值: 如果成功，则返回信号量集合的IPC识别号
  
如果为-1，则出现错误：
  
semget()中的第一个参数是键值， 这个键值要与已有的键值进行比较，已有的键值指在内核中已存在的其它信号量集合的键值。对信号量集合的打开或存取操作依赖于semflg参数的取值：IPC_CREAT ：如果内核中没有新创建的信号量集合，则创建它。
  
IPC\_EXCL ：当与IPC\_CREAT一起使用时，但信号量集合已经存在，则创建失败。如果IPC\_CREAT单独使用，semget()为一个新建的集合返回标识 号，或者返回具有相同键值的已存在集合的标识号。如果IPC\_EXCL与IPC\_CREAT一起使用，要么创建一个新的集合，要么对已存在的集合返回 -1。IPC\_EXCL单独是没有用的，当与IPC_CREAT结合起来使用时，可以保证新创建集合的打开和存取。作为System V IPC的其它形式，一种可选项是把一个八进制与掩码或，形成信号量集合的存取权限。第三个参数nsems指的是在新创建的集合中信号量的个数。其最大值在 "linux/sem.h"中定义：

#define SEMMSL 250 /\* SHMMAX的指针数组 \*/
  
struct vm\_area\_struct \*attaches; /\* 对共享段的描述 */
  
};

2. 共享内存的处理过程

某个进程第一次访问共享虚拟内存时将产生缺页异常。这时，Linux 找出描述该内存的 vm\_area\_struct 结构，该结构中包含用来处理这种共享虚拟内存段的处理函数地址。共享内存缺页异常处理代码对shmid\_ds 的页表项表进行搜索，以便查看是否存在该共享虚拟内存的页表项。如果没有，系统将分配一个物理页并建立页表项，该页表项加入 shmid\_ds 结构的同时也添加到进程的页表中。这就意味着当下一个进程试图访问这页内存时出现缺页异常，共享内存的缺页异常处理代码则把新创建的物理页给这个进程。因 此说，第一个进程对共享内存的存取引起创建新的物理页面，而其它进程对共享内存的存取引起把那个页加添加到它们的地址空间。

当某个进程不再共享其虚拟内存时，利用系统调用将共享段从自己的虚拟地址区域中移去，并更新进程页表。当最后一个进程释放了共享段之后，系统将释放给共享段所分配的物理页。

当共享的虚拟内存没有被锁定到物理内存时，共享内存也可能会被交换到交换区中。

3. 系统调用：shmget()

原型：int shmget ( key_t key, int size, int shmflg );

返回：成功，则返回共享内存段的识别号, 失败返回-1

shmget()系统调用类似于信号量和消息队列的系统调用，在此不进一步赘述。

4. 系统调用：shmat()

原型： int shmat ( int shmid, char *shmaddr, int shmflg);

返回：成功，则返回附加到进程的那个段的地址，失败返回-1。

其中shmid是由shmget()调用返回的共享内存段识别号，shmaddr是你希望共享段附加的地址，shmflag允许你规定希望所附加的段为只 读(利用SHM_RDONLY)以代替读写。通常，并不需要规定你自己的shmaddr，可以用传递参数值零使得系统为你取得一个地址。

这个调用可能是最简单的，下面看一个例子，把一个有效的识别号传递给一个段，然后返回这个段被附加到内存的内存地址。

char *attach_segment( int shmid )
  
{
  
return(shmat(shmid, 0, 0));
  
}
  
一旦一个段适当地被附加，并且一个进程有指向那个段起始地址的一个指针，那么，对那个段的读写就变得相当容易。

5. 系统调用： shmctl()

原型： int shmctl ( int shmqid, int cmd, struct shmid_ds *buf );

返回：成功为 0 ， 失败 为-1

这个特殊的调用和semctl()调用几乎相同，因此，这里不进行详细的讨论。有效命令的值是：

IPC\_STAT ：检索一个共享段的shmid\_ds结构，把它存到buf参数的地址中。

IPC\_SET ：对一个共享段来说，从buf 参数中取值设置shmid\_ds结构的ipc_perm域的值。

IPC_RMID ：把一个段标记为删除

IPC_RMID 命令实际上不从内核删除一个段，而是仅仅把这个段标记为删除，实际的删除发生在最后一个进程离开这个共享段时。
  
当一个进程不再需要共享内存段时，它将调用shmdt()系统调用取消这个段，但是，这并不是从内核真正地删除这个段，而是把相关shmid\_ds结构的 shm\_nattch域的值减1，当这个值为0时，内核才从物理上删除这个共享段。