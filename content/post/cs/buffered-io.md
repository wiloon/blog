---
title: 缓冲IO, 缓冲I/O, buffered I/O
author: "-"
date: 2014-07-28T09:10:49+00:00
url: buffered-io
categories:
  - os
tags:
  - reprint
  - io
---
## 缓冲IO, 缓冲I/O, buffered I/O

在系统调用的函数中有 STDIN_FILENO 和 STDOUT_FILENO, STDERR_FILENO, 分别对应标准输入(一般使键盘)，标准输出 (一般使显示器），标准错误，(他们都是非负整数，属于文件描述符)。一般在老程序中也将他们分别用 0，1，2 代替，但建议还是使用他们的别名。

在标准IO函数中还有stdin,stdout,stderr等是 FILE * 类型，是属于文件指针，属于标准I/O，高级的输入输出函数。在<stdio.h>中。


而STDIN_FILENO等是文件描述符，是非负整数，一般定义为0, 1, 2，属于没有buffer的I/O，直接调用系统调用，

在<unistd.h>zh 。 
****************************************************************************************************
stdin是文件指针，是FILE *类型
STDIN_FILENO是文件描述符，是int类型的
stdout和STDOUT_FILENO同样。
所以使用fread(,,stdin)，而read(STDOUT_FILENO)，因为函数的参数类型是不一样的 

*****************************************************************************************************

二.
下面使网上的一篇文章，讲解缓冲IO和不带缓冲IO
首先，先稍微了解系统调用的概念：
      系统调用，英文名system call，每个操作系统都在内核里有一些内建的函数库，这些函数可以用来完成一些系统系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序，如果没有系统调用和内核函数，用户将不能编写大型应用程序，及别的功能，这些函数集合起来就叫做程序接口或应用编程接口(Application Programming Interface，API)，我们要在这个系统上编写各种应用程序，就是通过这个API接口来调用系统内核里面的函数。如果没有系统调用，那么应用程序就失去内核的支持。


现在，再聊不带缓存的I/O操作：
     linix对IO文件的操作分为不带缓存的IO操作和标准IO操作 (即带缓存），刚开始，要明确以下几点：
     1：不带缓存，不是直接对磁盘文件进行读取操作,像read()和write()函数，它们都属于系统调用，只不过在用户层没有缓存，所以叫做无缓存IO,但对于内核来说，还是进行了缓存，只是用户层看不到罢了。如果这一点看不懂，请看第二点；
    2：带不带缓存是相对来说的，如果你要写入数据到文件上时 (就是写入磁盘上），内核先将数据写入到内核中所设的缓冲储存器，假如这个缓冲储存器的长度是100个字节，你调用系统函数：
ssize_t write (int fd,const void * buf,size_t count);
     写操作时，设每次写入长度count=10个字节，那么你几要调用10次这个函数才能把这个缓冲区写满，此时数据还是在缓冲区，并没有写入到磁盘，缓冲区满时才进行实际上的IO操作，把数据写入到磁盘上，所以上面说的“不带缓存不是就没有缓存直写进磁盘”就是这个意思。


     那么，既然不带缓存的操作实际在内核是有缓存器的，那带缓存的IO操作又是怎么回事呢？
     带缓存IO也叫标准IO，符合ANSI C 的标准IO处理，不依赖系统内核，所以移植性强，我们使用标准IO操作很多时候是为了减少对read()和write()的系统调用次数，带缓存IO其实就是在用户层再建立一个缓存区，这个缓存区的分配和优化长度等细节都是标准IO库代你处理好了，不用去操心，还是用上面那个例子说明这个操作过程：
     上面说要写数据到文件上，内核缓存 (注意这个不是用户层缓存区）区长度是100字节，我们调用不带缓存的IO函数write()就要调用10次，这样系统效率低，现在我们在用户层建立另一个缓存区 (用户层缓存区或者叫流缓存），假设流缓存的长度是50字节，我们用标准C库函数的fwrite()将数据写入到这个流缓存区里面，流缓存区满50字节后在进入内核缓存区，此时再调用系统函数write()将数据写入到文件 (实质是磁盘）上，看到这里，你用该明白一点，标准IO操作fwrite()最后还是要掉用无缓存IO操作write,这里进行了两次调用fwrite()写100字节也就是进行两次系统调用write()。
    如果看到这里还没有一点眉目的话，那就比较麻烦了，希望下面两条总结能够帮上忙：
    无缓存IO操作数据流向路径：数据——内核缓存区——磁盘
    标准IO操作数据流向路径：数据——流缓存区——内核缓存区——磁盘



三.
    下面是一个网友的见解，以供参考：
    不带缓存的I/O对是文件描述符操作，下面带缓存的I/O是针对流的。
    标准I/O库就是带缓存的I/O，它由ANSI C标准说明。当然，标准I/O最终都会调用上面的I/O例程。标准I/O库代替用户处理很多细节，比如缓存分配、以优化长度执行I/O等。
    标准I/O提供缓存的目的就是减少调用read和write的次数，它对每个I/O流自动进行缓存管理 (标准I/O函数通常调用malloc来分配缓存）。它提供了三种类型的缓存：
    1) 全缓存。当填满标准I/O缓存后才执行I/O操作。磁盘上的文件通常是全缓存的。
    2) 行缓存。当输入输出遇到新行符或缓存满时，才由标准I/O库执行实际I/O操作。stdin、stdout通常是行缓存的。
    3) 无缓存。相当于read、write了。stderr通常是无缓存的，因为它必须尽快输出。


    一般而言，由系统选择缓存的长度，并自动分配。标准I/O库在关闭流的时候自动释放缓存。
    在标准I / O库中，一个效率不高的不足之处是需要复制的数据量。当使用每次一行函数fgets和fputs时，通常需要复制两次数据：一次是在内核和标准I / O缓存之间 (当调用read和write时），第二次是在标准I / O缓存 (通常系统分配和管理）和用户程序中的行缓存 (fgets的参数就需要一个用户行缓存指针）之间。


    不管上面讲的到底懂没懂，记住一点：
    使用标准I / O例程的一个优点是无需考虑缓存及最佳I / O长度的选择，并且它并不比直接调用read、write慢多少。
    带缓存的文件操作是标准C 库的实现，第一次调用带缓存的文件操作函数时标准库会自动分配内存并且读出一段固定大小的内容存储在缓存中。所以以后每次的读写操作并不是针对硬盘上的文件直接进行的，而是针对内存中的缓存的。何时从硬盘中读取文件或者向硬盘中写入文件有标准库的机制控制。不带缓存的文件操作通常都是系统提供的系统调用，更加低级，直接从硬盘中读取和写入文件，由于 IO瓶颈的原因，速度并不如意，而且原子操作需要程序员自己保证，但使用得当的话效率并不差。另外标准库中的带缓存文件IO 是调用系统提供的不带缓存IO实现的。
这里为了说明标准I/O的工作原理,借用了glibc中标准I/O实现的细节,所以代码多是不可移植的.


1. buffered I/O, 即标准I/O
首先,要明确,unbuffered I/O只是相对于buffered I/O,即标准I/O来说的.
而不是说unbuffered I/O读写磁盘时不用缓冲.实际上,内核是存在高速缓冲区来进行真正的磁盘读写的,不过这里要讨论的buffer跟内核中的缓冲区无关.


buffered I/O的目的是什么呢?
很简单,buffered I/O的目的就是为了提高效率.
请明确一个关系,那就是,                  
buffered I/O库函数(fread, fwrite等,用户空间) <----call--->  unbuffered I/O系统调用(read,write等,内核空间)<-------> 读写磁盘


buffered I/O库函数都是调用相关的unbuffered I/O系统调用来实现的,他们并不直接读写磁盘.


那么,效率的提高从何而来呢?
注意到,buffered I/O中都是库函数,而unbuffered I/O中为系统调用,使用库函数的效率是高于使用系统调用的.


buffered I/O就是通过尽可能的少使用系统调用来提高效率的.


它的基本方法是,在用户进程空间维护一块缓冲区,第一次读(库函数)的时候用read(系统调用)多从内核读出一些数据,
下次在要读(库函数)数据的时候,先从该缓冲区读,而不用进行再次read(系统调用)了.
同样,写的时候,先将数据写入(库函数)一个缓冲区,多次以后,在集中进行一次write(系统调用),写入内核空间.


buffered I/O中的fgets, puts, fread, fwrite等和unbufferedI/O中的read,write等就是调用和被调用的关系。

>https://blog.csdn.net/scottly1/article/details/24186719

