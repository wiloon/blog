---
title: '字节序  大端 小端'
author: "-"
date: 2020-03-19T10:43:31+00:00
url: /?p=15779
categories:
  - Inbox
tags:
  - reprint
---
## '字节序  大端 小端'
大端字节序 (big endian) 和小端字节序 (little endian) 。
什么会有小端字节序？
答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。
但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。
计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。
如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。
理解这一点，才能理解计算机如何处理字节序。

字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。
字节序分为两类: Big-Endian 和 Little-Endian，引用标准的 Big-Endian 和 Little-Endian 的定义如下: 
Little-Endian: 就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
Big-Endian: 就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
网络字节序: TCP/IP各层协议将字节序定义为 Big-Endian (这与主机序相反) ，因此TCP/IP协议中使用的字节序通常称之为网络字节序。

### 示例
举例来说，数值0x2211使用两个字节储存: 高位字节是0x22，低位字节是0x11。
大端字节序: 高位字节在前，低位字节在后，这是人类读写数值的方法。
小端字节序: 低位字节在前，高位字节在后，即以0x1122形式储存。

### 比特序
比特序(bit order)
字节序是一个对象中的多个字节之间的顺序问题，比特序就是一个字节中的8个比特位(bit)之间的顺序问题。一般情况下系统的比特序和字节序是保持一致的。
一个字节由8个bit组成，这8个bit也存在如何排序的情况，跟字节序类似的有最高有效比特位、最低有效比特位。
比特序1 0 0 1 0 0 1 0在大端系统中最高有效比特位为1、最低有效比特位为0，字节的值为0x92。在小端系统中最高、最低有效比特位则相反为0、1，字节的值为0x49。
跟字节序类似，要想保持一个字节值不变那么就要使系统能正确的识别最高、最低有效比特位。
字节序转换函数ntohl(s)、htonl(s)
在socket编程中经常要用到网络字节序转换函数ntohl、htonl来进行主机序和网络序(大端序)的转换，在主机序为小端的系统中字节序列78 56 34 12(val=0x12345678)经过htonl转换后字节序列变成12 34 56 78: 

版权声明: 本文为CSDN博主「NoneSec」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接: https://blog.csdn.net/liuxingen/java/article/details/45420455
https://www.ruanyifeng.com/blog/2016/11/byte-order.html
https://blog.erratasec.com/2016/11/how-to-teach-endian.html#.XnB-KHVfjmE
