---
title: 线程
author: w1100n
type: post
date: "2017-06-02 17:35:41"
draft: true
url: /?p=10461

---

Linux线程的发展

早在LINUX2.2内核中。并不存在真正意义上的线程，当时Linux中常用的线程pthread实际上是通过进程来模拟的，也就是同过fork来创建“轻”进程，并且这种轻进程的线程也有个数的限制：最多只能有4096和此类线程同时运行。
2.4内核消除了个数上的限制，并且允许在系统运行中动态的调整进程数的上限，当时采用的是Linux Thread 线程库，它对应的线程模型是“一对一”，而线程的管理是在内核为的函数库中实现，这种线程得到了广泛的应用。但是它不与POSIX兼容。另外还有许多诸如信号处理，进程ID等方面的问题没有完全解决。 
相似新的2.6内核中，进程调度通过重新的编写，删除了以前版本中的效率不高的算法，内核框架页也被重新编写。开始使用NPTL(Native POSIX Thread Library)线程库，这个线程库有以下几个目标： POSIX兼容，都处理结果和应用，底启动开销，低链接开销，与Linux Thread应用的二进制兼容，软硬件的可扩展能力，与C++集成等。 这一切使2.6的内核多线程机制更加完备。


死锁，
活锁，
优先级反转

线程模型好就好在，它的资源分享: 共享变量
角色模型（Actor Model） 比线程模型好就好在，它的资源分享不像线程模型那样通过共享变量来进行。  角色模型中的资源分享只能通过特定的机制（消息传递）来进行。   

RMI TCP connection  
to feed a remote JMX client (in your case Java VisualVM) with data from JVM.    
https://stackoverflow.com/questions/40793580/what-is-rmi-tcp-connection

### Pthread
POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用 Pthreads 作为操作系统的线程。Windows操作系统也有其移植版pthreads-win32。

### 抽象
抽象的实质是对问题的转换。我们可以把抽象应用于一个问题，把它转换成另一个（或许）更简单的问题来解决。解决了转换后的简单问题，就意味着解决了原有的困难问题。严格来说，一个抽象一定要保存原有问题的结构，同时去除无关细节。但是，由于我们生活的世界并没有什么东西是完全“严格”的，现实中使用的抽象有时会隐藏解决问题的关键细节，或者残留一些不该漏出来的东西。评价一个抽象的好坏，也就不止是看它能节省多少代码，和它的界面有多优美这么简单，同时还要看看在一个问题被抽象转换之后，留了下来的细节还能不能好好地解决它。

一般来说，在修复一个糟糕的抽象时，可以采取的策略分如下两类：

把造成问题的那部分抽象拿掉，直接露出底层的细节
换一个和底层兼容性更好的抽象模型

角色模型，通信进程（Communicating Sequential Processes, CSP），以及函数式编程（FP）

墨菲定律的变体：布劳尔技术惯性定律（已经成功的技术在新的，更好的技术出现时也会赖着不走）


### 线程栈
先从操作系统的角度来复习下基础知识，进程是操作系统进行资源分配的基本单位，线程是CPU进行调度和分派的基本单位。我们通常意义下的进程包括：由二进制代码组成的应用程序、单线程、分配给该应用程序的一组资源（如内存、文件等）
  
wikipedia上叫callstack调用栈，并不是孤立的有进程栈这个说法，进程只是在分配时通过如随机化方式指定了栈底的初始地址，进程的子线程们有各自的私有栈，可以共享父进程分配的堆内存空间，只有一个主线程的进程也就是有主线程对应的栈，所以栈这个说法通常只有线程栈，并没有明确的进程栈之说，那就更没有所谓的进程栈大小了。
  
线程栈：
  
线程包含了表示进程内执行环境必需的信息，其中包括进程中标示线程的线程ID，一组寄存器值，栈，调度优先级和策略， 信号屏蔽字，errno变量以及线程私有数据。进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本，程序的全局内存和堆内存，栈以及文件描述符.
  
线程栈起始于进程虚拟 内存的高端地址，并向虚拟内存底端地址方向扩展。取决于线程本身的大小以及其它线程内存分配的情况，进程虚拟地址空间消耗过快可能导致创建线程失败。

我们通常使用ulimit -s可以看到"进程对应栈"的大小（现代linux系统下通常是8MB大小），不论在只有一个主线程的进程中，还是包含许多子线程的进程，都是指线程栈大小，默认8MB，
  
线程栈的空间开辟在所属进程的堆区，线程与其所属的进程共享进程的用户空间，所以线程栈之间可以互访。

通过/proc/PID/task来看该程序有多少线程在运行
  
进程的地址空间 /proc/PID/maps

### for java
不显式设置-Xss或-XX:ThreadStackSize时，在Linux x64上ThreadStackSize的默认值就是1024KB，给Java线程创建栈会用这个参数指定的大小。这是前一块代码的意思。如果把-Xss或者-XX:ThreadStackSize设为0，就是使用"系统默认值"。而在Linux x64上HotSpot VM给Java栈定义的"系统默认"大小也是1MB。所以这个条件下普通Java线程的默认栈大小怎样都是1MB。至于操作系统栈大小（ulimit -s）：这个配置只影响进程的初始线程；后续用pthread_create创建的线程都可以指定栈大小。HotSpot VM为了能精确控制Java线程的栈大小，特意不使用进程的初始线程（primordial thread）作为Java线程。

https://www.zhihu.com/question/27844575/answer/38370294
http://laoar.net/blogs/250/
  
http://blog.csdn.net/daniel_ice/article/details/8146003
  
http://blog.csdn.net/yjzl1911/article/details/5629537

<blockquote data-secret="iaqm21dSlH" class="wp-embedded-content">
  
    <a href="http://www.pandademo.com/2015/10/linux-process-and-thread-stack-size/">Linux 进程栈与线程栈大小</a>
  
</blockquote>

http://www.pandademo.com/2015/10/linux-process-and-thread-stack-size/embed/#?secret=iaqm21dSlH

https://www.zhihu.com/question/27844575

---

https://coolshell.cn/articles/4626.html

---

https://coolshell.cn/articles/10249.html
