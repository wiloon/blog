---
title: 进程, 线程
author: w1100n
type: post
date: "2017-06-02 17:35:41"
draft: true
url: /?p=10461

---
在现代操作系统中，进程支持多线程。

进程是资源管理的最小单元， 进程是作为资源分配的基本单位。

线程是程序执行的最小单元， 是进程中的实际运作单位， 是被系统独立调度和分派的基本单位。

即线程作为调度和分配的基本单位，进程作为资源分配的基本单位

### 单线程进程的缺点
现实中有很多需要并发处理的任务，如数据库的服务器端、网络服务器、大容量计算等。

传统的UNIX进程是单线程的，单线程意味着程序必须是顺序执行，不能并发；既在一个时刻只能运行在一个处理器上，因此不能充分利用多处理器框架的计算机。

如果采用多进程的方法，则有如下问题：

fork一个子进程的消耗是很大的，fork是一个昂贵的系统调用，即使使用现代的写时复制(copy-on-write)技术。
各个进程拥有自己独立的地址空间，进程间的协作需要复杂的IPC技术，如消息传递和共享内存等。

### 多线程的优缺点
多线程的优点和缺点实际上是对立统一的。

支持多线程的程序(进程)可以取得真正的并行(parallelism)，且由于共享进程的代码和全局数据，故线程间的通信是方便的。它的缺点也是由于线程共享进程的地址空间，因此可能会导致竞争，因此对某一块有多个线程要访问的数据需要一些同步技术。

线程的设计过程演变
在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。

SMP机器上多线程的并行性
无论按照怎样的分法，一个进程至少需要一个线程作为它的指令执行体，进程管理着资源（比如cpu、内存、文件等等），而将线程分配到某个cpu上执 行。

一个进程当然可以拥有多个线程，此时，如果进程运行在SMP机器上，它就可以同时使用多个cpu来执行各个线程，达到最大程度的并行，以提高效率；同 时，即使是在单cpu的机器上，采用多线程模型来设计程序，正如当年采用多进程模型代替单进程模型一样，使设计更简洁、功能更完备，程序的执行效率也更 高，例如采用多个线程响应多个输入，而此时多线程模型所实现的功能实际上也可以用多进程模型来实现，而与后者相比，线程的上下文切换开销就比进程要小多 了，从语义上来说，同时响应多个输入这样的功能，实际上就是共享了除cpu以外的所有资源的。

线程模型–核心级线程和用户级线程
针对线程模型的两大意义，分别开发出了核心级线程和用户级线程两种线程模型，分类的标准主要是线程的调度者在核内还是在核外。前者更利于并发使用多处理器的资源，而后者则更多考虑的是上下文切换开销。
目前的实现策略
在目前的商用系统中，通常都将两者结合起来使用，既提供核心线程以满足smp系统的需要，也支持用线 程库的方式在用户态实现另一套线程机制，此时一个核心线程同时成为多个用户态线程的调度者。

正如很多技术一样，”混合”通常都能带来更高的效率，但同时也 带来更大的实现难度，出于”简单”的设计思路，Linux从一开始就没有实现混合模型的计划，但它在实现上采用了另一种思路的”混合”。

在线程机制的具体实现上，可以在操作系统内核上实现线程，也可以在核外实现，后者显然要求核内至少实现了进程，而前者则一般要求在核内同时也支持进 程。核心级线程模型显然要求前者的支持，而用户级线程模型则不一定基于后者实现。这种差异，正如前所述，是两种分类方式的标准不同带来的。

当核内既支持进程也支持线程时，就可以实现线程-进程的”多对多”模型，即一个进程的某个线程由核内调度，而同时它也可以作为用户级线程池的调度 者，选择合适的用户级线程在其空间中运行。这就是前面提到的”混合”线程模型，既可满足多处理机系统的需要，也可以最大限度的减小调度开销。

绝大多数商业 操作系统（如Digital Unix、Solaris、Irix）都采用的这种能够完全实现POSIX1003.1c标准的线程模型。在核外实现的线程又可以分为”一对一”、”多对 一”两种模型，前者用一个核心进程（也许是轻量进程）对应一个线程，将线程调度等同于进程调度，交给核心完成，而后者则完全在核外实现多线程，调度也在用 户态完成。后者就是前面提到的单纯的用户级线程模型的实现方式，显然，这种核外的线程调度器实际上只需要完成线程运行栈的切换，调度开销非常小，但同时因 为核心信号（无论是同步的还是异步的）都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统，而这个需求正变得越来越大，因 此，在现实中，纯用户级线程的实现，除算法研究目的以外，几乎已经消失了。

Linux内核只提供了轻量进程的支持，限制了更高效的线程模型的实现，但Linux着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前 最流行的线程机制LinuxThreads所采用的就是线程-进程”一对一”模型，调度交给核心，而在用户级实现一个包括信号处理在内的线程管理机制。
三种线程概念——内核线程、轻量级进程、用户线程
内核线程
内核线程就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步IO时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核(Multi-Threads kernel )。

内核线程只运行在内核态，不受用户态上下文的拖累。

处理器竞争：可以在全系统范围内竞争处理器资源；

使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间

调度：调度的开销可能和进程自身差不多昂贵

同步效率：资源的同步和数据共享比整个进程的数据同步和共享要低一些。
轻量级进程
轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。

a LWP runs in user space on top of a single kernel thread and shares its address space and system resources with other LWPs within the same process

轻量级进程由clone()系统调用创建，参数是CLONE_VM，即与父进程是共享进程地址空间和系统资源。

与普通进程区别：LWP只有一个最小的执行上下文和调度程序所需的统计信息。

处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源

使用资源：与父进程共享进程地址空间

调度：像普通进程一样调度

轻量级线程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。每一个进程有一个或多个LWPs，每个LWP由一个内核线程支持。这种模型实际上就是恐龙书上所提到的一对一线程模型。在这种实现的操作系统中，LWP就是用户线程。

由于每个LWP都与一个特定的内核线程关联，因此每个LWP都是一个独立的线程调度单元。即使有一个LWP在系统调用中阻塞，也不会影响整个进程的执行。

轻量级进程具有局限性。

首先，大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高：需要在user mode和kernel mode中切换。

其次，每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的LWP。

这里写图片描述

注：

LWP的术语是借自于SVR4/MP和Solaris 2.x。
有些系统将LWP称为虚拟处理器。
将之称为轻量级进程的原因可能是：在内核线程的支持下，LWP是独立的调度单元，就像普通的进程一样。所以LWP的最大特点还是每个LWP都有一个内核线程支持。

用户线程
用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。

处理器竞争：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。

使用资源：与所属进程共享进程地址空间和系统资源。

调度：由在用户空间实现的线程库，在所属进程内进行调度

LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。

这里写图片描述

上图是最初的一个用户线程模型，从中可以看出，进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。

用户线程之间的调度由在用户空间实现的线程库实现。

这种模型对应着恐龙书中提到的多对一线程模型，其缺点是一个用户线程如果阻塞在系统调用中，则整个进程都将会阻塞。

加强版的用户线程——用户线程+LWP
这种模型对应着恐龙书中多对多模型。

用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，因此可以建立任意多需要的用户线程。

操作系统提供了LWP作为用户线程和内核线程之间的桥梁。LWP还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过LWP，因此进程中某个用户线程的阻塞不会影响整个进程的执行。

用户线程库将建立的用户线程关联到LWP上，LWP与用户线程的数量不一定一致。当内核调度到某个LWP上时，此时与该LWP关联的用户线程就被执行。

这里写图片描述

Linux使用的线程库
LinuxThreads是用户空间的线程库，所采用的是线程-进程1对1模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定的内核线程)，将线程的调度等同于进程的调度，调度交由内核完成，而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。

在LinuxThreads中，由专门的一个管理线程处理所有的线程管理工作。当进程第一次调用pthread_create()创建线程时就会先 创建(clone())并启动管理线程。后续进程pthread_create()创建线程时，都是管理线程作为pthread_create()的调用者的子线程，通过调用clone()来创建用户线程，并记录轻量级进程号和线程id的映射关系，因此，用户线程其实是管理线程的子线程。

LinuxThreads只支持调度范围为PTHREAD_SCOPE_SYSTEM的调度，默认的调度策略是SCHED_OTHER。
用户线程调度策略也可修改成SCHED_FIFO或SCHED_RR方式，这两种方式支持优先级为0-99,而SCHED_OTHER只支持0。

SCHED_OTHER 分时调度策略，

SCHED_FIFO 实时调度策略，先到先服务

SCHED_RR 实时调度策略，时间片轮转

SCHED_OTHER是普通进程的，后两个是实时进程的（一般的进程都是普通进程，系统中出现实时进程的机会很少）。SCHED_FIFO、 SCHED_RR优先级高于所有SCHED_OTHER的进程，所以只要他们能够运行，在他们运行完之前，所有SCHED_OTHER的进程的都没有得到 执行的机会

小结：

很多文献中都认为轻量级进程就是线程，实际上这种说法并不完全正确，从前面的分析中可以看到，只有在用户线程完全由轻量级进程构成时，才可以说轻量级进程就是线程。


1 线程的3种实现方式
在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换

根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程

名称	描述
用户级线程(User-LevelThread, ULT)	由应用程序所支持的线程实现, 内核意识不到用户级线程的实现
内核级线程(Kemel-LevelThread, KLT)	内核级线程又称为内核支持的线程


在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程


有些情况下,也把内核级线程叫做轻量级进程(LWP), 但是这个是一个不准备的描述, 其实LWP的术语是借自于SVR4/MP和Solaris 2.x系统中, 有些系统将LWP称为虚拟处理器, 将之称为轻量级进程的原因可能是, 在内核线程的支持下，LWP是独立的调度单元，就像普通的进程一样。所以LWP的最大特点还是每个LWP都有一个内核线程支持

2 用户级线程(多对一模型)
2.1 线程的用户级线程实现方式
在用户级线程中，

有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在. 应用程序可以通过使用线程库设计成多线程程序. 通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。

用户级线程仅存在于用户空间中，此类线程的创建、撤销、线程之间的同步与通信功能，都无须利用系统调用来实现。用户进程利用线程库来控制用户线程。由于线程在进程内切换的规则远比进程调度和切换的规则简单，不需要用户态/核心态切换，所以切换速度快。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，这些运行库被称为“线程包”，用户线程是不能被操作系统所感知的。用户线程多见于一些历史悠久的操作系统，例如Unix操作系统

用户级线程驻留在用户空间或模式。运行时库管理这些线程，它也位于用户空间。它们对于操作系统是不可见的，因此无法被调度到处理器内核。每个线程并不具有自身的线程上下文。因此，就线程的同时执行而言，任意给定时刻每个进程只能够有一个线程在运行，而且只有一个处理器内核会被分配给该进程。对于一个进程，可能有成千上万个用户级线程，但是它们对系统资源没有影响。运行时库调度并分派这些线程。

下图说明了用户级线程的实现方式,



如同在图中看到的那样，库调度器从进程的多个线程中选择一个线程，然后该线程和该进程允许的一个内核线程关联起来。内核线程将被操作系统调度器指派到处理器内核。用户级线程是一种”多对一”的线程映射

2.2 用户级线程的特点
内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程（存在运行时系统）

2.3 用户级线程的优点
用户线程的优点主要有

可以在不支持线程的操作系统中实现。

创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多, 因为保存线程状态的过程和调用程序都只是本地过程

允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别

线程能够利用的表空间和堆栈空间比内核级线程多

不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷

线程的调度不需要内核直接参与，控制简单。
2.4 用户线程的缺点
用户线程的缺点主要有

线程发生I/O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行

页面失效也会产生类似的问题。

一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程

资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用

补充
在用户级线程中，每个进程里的线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放的进程的信息完全一样

3 内核级线程
3.1 线程的内核级线程实现
在内核级线程中，

内核线程建立和销毁都是由操作系统负责、通过系统调用完成的。在内核的支持下运行，无论是用户进程的线程，或者是系统进程的线程，他们的创建、撤销、切换都是依靠内核实现的。

线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口. 内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。图2-2(b)说明了内核级线程的实现方式。


内核线程驻留在内核空间，它们是内核对象。有了内核线程，每个用户线程被映射或绑定到一个内核线程。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作”一对一”线程映射，

线程的创建、撤销和切换等，都需要内核直接实现，即内核了解每一个作为可调度实体的线程

这些线程可以在全系统内进行资源的竞争

内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制

如图所示,即内核级线程的实现方式, 每个用户线程都直接与一个内核线程相关联.




操作系统调度器管理、调度并分派这些线程。运行时库为每个用户级线程请求一个内核级线程。操作系统的内存管理和调度子系统必须要考虑到数量巨大的用户级线程。您必须了解每个进程允许的线程的最大数目是多少。操作系统为每个线程创建上下文。进程的每个线程在资源可用时都可以被指派到处理器内核。

3.2 内核线程的特点
当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用

3.3 内核线程的优点
内核线程的优点:

多处理器系统中，内核能够并行执行同一进程内的多个线程

如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点）

所有能够阻塞线程的调用都以系统调用的形式实现，代价可观

当一个线程阻塞时，内核根据选择可以运行另一个进程的线程，而用户空间实现的线程中，运行时系统始终运行自己进程中的线程

信号是发给进程而不是线程的，当一个信号到达时，应该由哪一个线程处理它？线程可以“注册”它们感兴趣的信号

4 组合方式
在一些系统中，使用组合方式的多线程实现, 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行. 一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。

下图说明了用户级与内核级的组合实现方式, 在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合



posix线程调度是一个混合模型，很灵活，足以在标准的特定实现中支持用户级和内核级的线程。模型中包括两级调度–线程及和内核实体级。线程级与用户级线程类似，内核实体由内核调度。由线程库来决定它需要多少内核实体，以及他们是如何映射的。

POSIX 引入了一个线程调度竞争范围(thread-scheduling contention scope)的概念，这个. 概念赋予了程序员一些控制权，使它们可以控制怎样将内核实体映射为线程。线程的contentionscope属性可是PTHREAD_SCOPE_PROCESS,也可以是PTHREAD_SCOPE_SYSTEM。带有PTHREAD_SCOPE_PROCESS属性的线程与它所在的进程中的其他线程竞争处理器资源。带有PTHREAD_SCOPE_SYSTEM属性的线程很像内核级线程，他们在全系统的范围内竞争处理器资源。POSIX的一种映射方式将PTHREAD_SCOPE_SYSTEM线程和内核实体之间绑定起来。

内核级线程创建时先设置线程属性PTHREAD_SCOPE_SYSTEM，代码如下，:

pthread_attr_t attr;

pthread_attr_init(&attr);
pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM); //设置内核级的线程,以获取较高的响应速度
//创建线程

ret = pthread_create(&iAcceptThreadId, &attr, AcceptThread, NULL);
1
2
3
4
5
6
7
POSIX的标准中定义了两个值：

PTHREAD_SCOPE_SYSTEM和PTHREAD_SCOPE_PROCESS，前者表示与系统中所有线程一起竞争CPU时间，后者表示仅与同进程中的线程竞争CPU

默认为PTHREAD_SCOPE_PROCESS。目前LinuxThreads仅实现了PTHREAD_SCOPE_SYSTEM一值。

关于线程的绑定，牵涉到另外一个概念：轻进程（LWP：Light Weight Process）。轻进程可以理解为内核线程，它位于用户层和系统层之间。系统对线程资源的分配、对线程的控制是通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认状况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定的。绑定状况下，则顾名思义，即某个线程固定的”绑”在一个轻进程之上。被绑定的线程具有较高的响应速度，这是因为CPU时间片的调度是面向轻进程的，绑定的线程可以保证在需要的时候它总有一个轻进程可用。通过设置被绑定的轻进程的优先级和调度级可以使得绑定的线程满足诸如实时反应之类的要求。

设置线程绑定状态的函数为pthread_attr_setscope，它有两个参数，第一个是指向属性结构的指针，第二个是绑定类型，它有两个取值：PTHREAD_SCOPE_SYSTEM（绑定的）和PTHREAD_SCOPE_PROCESS（非绑定的）。

5 用户级线程和内核级线程的区别
内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。

用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。

用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。

在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。

用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。
————————————————
版权声明：本文为CSDN博主「CHENG Jian」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/gatieme/article/details/51892437

---

一个进程的组成实体可以分为两大部分：线程集和资源集。进程中的线程是动态的对象；代表了进程指令的执行。资源，包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。

从线程的运行空间来说，分为用户级线程（user-level thread, ULT）和内核级线程（kernel-level, KLT）。分类标准主要是线程的调度者是在核内还核外。还有一种线程叫做轻量级进程（lightweight process, LWP）。

### 单线程和多线程
进程中的所有线程共享该进程的状态和资源，它们驻留在同一块地址空间中，当一个线程改变了内存中的一个数据项时，其他线程在访问这一数据项时能够看到变化后的结果。
线程相比单线程的优点是可并发、效率高；而缺点是资源竞争带来的不稳定，比如死锁问题，因此对有多个线程要访问的数据需要一些同步技术。

### Linux线程的发展

早在LINUX2.2内核中。并不存在真正意义上的线程，当时Linux中常用的线程pthread实际上是通过进程来模拟的，也就是同过fork来创建“轻”进程，并且这种轻进程的线程也有个数的限制：最多只能有4096和此类线程同时运行。
2.4内核消除了个数上的限制，并且允许在系统运行中动态的调整进程数的上限，当时采用的是Linux Thread 线程库，它对应的线程模型是“一对一”，而线程的管理是在内核为的函数库中实现，这种线程得到了广泛的应用。但是它不与POSIX兼容。另外还有许多诸如信号处理，进程ID等方面的问题没有完全解决。 
相似新的2.6内核中，进程调度通过重新的编写，删除了以前版本中的效率不高的算法，内核框架页也被重新编写。开始使用NPTL(Native POSIX Thread Library)线程库，这个线程库有以下几个目标： POSIX兼容，都处理结果和应用，底启动开销，低链接开销，与Linux Thread应用的二进制兼容，软硬件的可扩展能力，与C++集成等。 这一切使2.6的内核多线程机制更加完备。


死锁，
活锁，
优先级反转

线程模型好就好在，它的资源分享: 共享变量
角色模型（Actor Model） 比线程模型好就好在，它的资源分享不像线程模型那样通过共享变量来进行。  角色模型中的资源分享只能通过特定的机制（消息传递）来进行。   

RMI TCP connection  
to feed a remote JMX client (in your case Java VisualVM) with data from JVM.    
https://stackoverflow.com/questions/40793580/what-is-rmi-tcp-connection

### Pthread
POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用 Pthreads 作为操作系统的线程。Windows操作系统也有其移植版pthreads-win32。

### 抽象
抽象的实质是对问题的转换。我们可以把抽象应用于一个问题，把它转换成另一个（或许）更简单的问题来解决。解决了转换后的简单问题，就意味着解决了原有的困难问题。严格来说，一个抽象一定要保存原有问题的结构，同时去除无关细节。但是，由于我们生活的世界并没有什么东西是完全“严格”的，现实中使用的抽象有时会隐藏解决问题的关键细节，或者残留一些不该漏出来的东西。评价一个抽象的好坏，也就不止是看它能节省多少代码，和它的界面有多优美这么简单，同时还要看看在一个问题被抽象转换之后，留了下来的细节还能不能好好地解决它。

一般来说，在修复一个糟糕的抽象时，可以采取的策略分如下两类：

把造成问题的那部分抽象拿掉，直接露出底层的细节
换一个和底层兼容性更好的抽象模型

角色模型，通信进程（Communicating Sequential Processes, CSP），以及函数式编程（FP）

墨菲定律的变体：布劳尔技术惯性定律（已经成功的技术在新的，更好的技术出现时也会赖着不走）


### 线程栈
先从操作系统的角度来复习下基础知识，进程是操作系统进行资源分配的基本单位，线程是CPU进行调度和分派的基本单位。我们通常意义下的进程包括：由二进制代码组成的应用程序、单线程、分配给该应用程序的一组资源（如内存、文件等）
  
wikipedia上叫callstack调用栈，并不是孤立的有进程栈这个说法，进程只是在分配时通过如随机化方式指定了栈底的初始地址，进程的子线程们有各自的私有栈，可以共享父进程分配的堆内存空间，只有一个主线程的进程也就是有主线程对应的栈，所以栈这个说法通常只有线程栈，并没有明确的进程栈之说，那就更没有所谓的进程栈大小了。
  
线程栈：
  
线程包含了表示进程内执行环境必需的信息，其中包括进程中标示线程的线程ID，一组寄存器值，栈，调度优先级和策略， 信号屏蔽字，errno变量以及线程私有数据。进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本，程序的全局内存和堆内存，栈以及文件描述符.
  
线程栈起始于进程虚拟 内存的高端地址，并向虚拟内存底端地址方向扩展。取决于线程本身的大小以及其它线程内存分配的情况，进程虚拟地址空间消耗过快可能导致创建线程失败。

我们通常使用ulimit -s可以看到"进程对应栈"的大小（现代linux系统下通常是8MB大小），不论在只有一个主线程的进程中，还是包含许多子线程的进程，都是指线程栈大小，默认8MB，
  
线程栈的空间开辟在所属进程的堆区，线程与其所属的进程共享进程的用户空间，所以线程栈之间可以互访。

通过/proc/PID/task来看该程序有多少线程在运行
  
进程的地址空间 /proc/PID/maps

### for java
不显式设置-Xss或-XX:ThreadStackSize时，在Linux x64上ThreadStackSize的默认值就是1024KB，给Java线程创建栈会用这个参数指定的大小。这是前一块代码的意思。如果把-Xss或者-XX:ThreadStackSize设为0，就是使用"系统默认值"。而在Linux x64上HotSpot VM给Java栈定义的"系统默认"大小也是1MB。所以这个条件下普通Java线程的默认栈大小怎样都是1MB。至于操作系统栈大小（ulimit -s）：这个配置只影响进程的初始线程；后续用pthread_create创建的线程都可以指定栈大小。HotSpot VM为了能精确控制Java线程的栈大小，特意不使用进程的初始线程（primordial thread）作为Java线程。

### linux 查看线程
其实linux没有线程，都是用进程模仿的  
```bash
ps -ef |grep xxx
# H Show threads as if they were processes, 查看所有存在的线程。
ps xH
# m Show threads after processes, 查看一个进程起的线程数
ps -mp <PID>

ps -Lf <PID>
ps -eLf |grep <PID>|grep -v grep
# tty值为“?”是守护进程，叫deamon 无终端，大多系统服务是此进程，内核态进程是看不到的
ps ax
ps axf #看进程树，以树形方式现实进程列表敲 ，init是1号进程，系统所有进程都是它派生的，杀不掉
ps axm #会把线程列出来。在Linux下进程和线程是统一的，是轻量级进程的两种方式。
ps axu ：显示进程的详细状态。
# “-T”选项可以开启线程查看。下面的命令列出了由进程号为<pid>的进程创建的所有线程。
ps -T -p <pid>
pstree -c
pstree -p <PID>
top -p <PID>
# -H : Threads toggle
top -Hp <PID>
top -bH -d 3 -p <PID>
cat /proc/<PID>/status
sudo gdb -batch -ex bt -p <PID>
```

### Htop
通过htop查看单个进程的线程，它是一个基于ncurses的交互进程查看器。该程序允许你在树状视图中监控单个独立线程。  
要在htop中启用线程查看，请开启htop，然后按<F2>来进入htop的设置菜单。选择“设置”栏下面的“显示选项”，然后开启“树状视图”和“显示自定义线程名”选项。按<F10>退出设置。

    htop -p 343496

### Linux进程类别
虽然我们在区分Linux进程类别, 但是我还是想说Linux下只有一种类型的进程，那就是task_struct，当然我也想说linux其实也没有线程的概念, 只是将那些与其他进程共享资源的进程称之为线程。
一个进程由于其运行空间的不同, 从而有内核线程和用户进程的区分, 内核线程运行在内核空间, 之所以称之为线程是因为它没有虚拟地址空间, 只能访问内核的代码和数据, 而用户进程则运行在用户空间, 但是可以通过中断, 系统调用等方式从用户态陷入内核态。
用户进程运行在用户空间上, 而一些通过共享资源实现的一组进程我们称之为线程组, Linux下内核其实本质上没有线程的概念, Linux下线程其实上是与其他进程共享某些资源的进程而已。但是我们习惯上还是称他们为线程或者轻量级进程

因此, Linux上进程分3种，内核线程（或者叫核心进程）、用户进程、用户线程, 当然如果更严谨的，你也可以认为用户进程和用户线程都是用户进程。

关于轻量级进程这个概念, 其实并不等价于线程
 不同的操作系统中依据其实现的不同, 轻量级进程其实是一个不一样的概念

 三种线程概念——内核线程、轻量级进程、用户线程
### 内核线程
内核级线程是指由内核管理、只运行在内核态、不受用户态上下文拖累的线程。其依赖于操作系统核心，由内核的内部需求进行创建和撤销。内核线程的线程表位于内核中，包括了线程控制块，一旦线程阻塞，内核会从当前或者其他进程中重现选择一个线程保证程序的执行。用户应用程序通过API和系统调用（system call）来访问内核级线程。

内核线程就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步IO时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核(Multi-Threads kernel )。

内核线程只运行在内核态，不受用户态上下文的拖累。

处理器竞争：可以在全系统范围内竞争处理器资源；
使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间
调度：调度的开销可能和进程自身差不多昂贵
同步效率：资源的同步和数据共享比整个进程的数据同步和共享要低一些。

内核级线程的缺点
  （1）把控制从一个线程传送到同一个进程的另一个线程时，需要到内核的状态切换，这样会造成系统开销。

### 轻量级进程 LWP, Light-weight process
轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。

轻量级进程由clone()系统调用创建，参数是CLONE_VM，即与父进程是共享进程地址空间和系统资源。

与普通进程区别：LWP只有一个最小的执行上下文和调度程序所需的统计信息。

处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源
使用资源：与父进程共享进程地址空间
调度：像普通进程一样调度
轻量级线程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。每一个进程有一个或多个LWPs，每个LWP由一个内核线程支持。这种模型实际上就是恐龙书上所提到的一对一线程模型。在这种实现的操作系统中，LWP就是用户线程。

由于每个LWP都与一个特定的内核线程关联，因此每个LWP都是一个独立的线程调度单元。即使有一个LWP在系统调用中阻塞，也不会影响整个进程的执行。

轻量级进程具有局限性。

首先，大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高：需要在user mode和kernel mode中切换。
其次，每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的LWP。

术语轻量级进程有几个不同的说法：1）等同于线程；2）等同于内核级线程；3）一种把用户级线程映射到内核级线程的实体。
  在这里取第三层意思。轻量级进程的创建完全在用户空间完成，进程的调度和同步也在应用程序中进行。每一个轻量级进程都与一个特定的内核线程建立映射关系，即每个轻量级进程由一个内核支持。当某个轻量级进程阻塞时，不会导致整个进程的阻塞。轻量级进程结合了用户级线程和内核级线程的优点，同时减少了他们的缺点。但是轻量级进程还是有局限性，因为每个轻量级进程都需要一个内核级线程支持，而内核级线程会消耗内核资源，因此一个系统不能支持大量的轻量级进程。
用户级线程、内核级线程和轻量级进程的比较
  （1）用户级线程和轻量级进程的创建和销毁都在用户空间完成，而内核级线程在内核内部创建。
  （2）用户级线程由线程库创建，轻量级进程由系统调用pthread_creat()来创建，内核级线程通过调用kernel_thread()来创建。但是轻量级进程和内核级线程的创建都使用内核接口clone()。

### 用户线程
用户级线程是指有关线程的管理工作都是由应用程序完成，内核意识不到用户级线程的存在，也不会对这些用户级线程进行调度。如果某个进程创建了多个用户级线程，那么所有这些用户级线程仅有一个对应的内核线程,在用户级线程策略中，内核是以进程为单位进行调度的，不管进程内有多少线程，内核一次只把一个进程分配给一个处理器，因此一个进程中只有一个线程可以执行，所以只有一个对应的内核线程。
用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。

处理器竞争：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。
使用资源：与所属进程共享进程地址空间和系统资源。
调度：由在用户空间实现的线程库，在所属进程内进行调度
LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。

进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。

用户线程之间的调度由在用户空间实现的线程库实现。

这种模型对应着恐龙书中提到的多对一线程模型，其缺点是一个用户线程如果阻塞在系统调用中，则整个进程都将会阻塞。

加强版的用户线程——用户线程+LWP
这种模型对应着恐龙书中多对多模型。

用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，因此可以建立任意多需要的用户线程。

操作系统提供了LWP作为用户线程和内核线程之间的桥梁。LWP还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过LWP，因此进程中某个用户线程的阻塞不会影响整个进程的执行。

用户线程库将建立的用户线程关联到LWP上，LWP与用户线程的数量不一定一致。当内核调度到某个LWP上时，此时与该LWP关联的用户线程就被执行。

用户级线程的优点
  （1）用户级线程切换不需要内核态特权，因此，进程不需要为了线程管理而切换到内核态，节省了两次状态转换（从用户态到内核态，从内核态返回到用户态）的开销。
  （2）用户级线程可以在任何操作系统上运行，不需要对底层内核进行修改以支持用户级线程。

用户级线程的缺点
  （1）当用户级线程执行一个系统调用时，不仅这个线程会被阻塞，进程中的所有线程都会被阻塞。
  （2）在一个纯粹的用户级线程中，一个多线程应用程序不能利用多处理器技术。而在现实中多处理系统变得越来越普遍，所以提供纯用户级线程的操作系统几乎没有了。

### 总结
Linux使用task_struct来描述进程和线程

一个进程由于其运行空间的不同, 从而有内核线程和用户进程的区分, 内核线程运行在内核空间, 之所以称之为线程是因为它没有虚拟地址空间, 只能访问内核的代码和数据, 而用户进程则运行在用户空间, 不能直接访问内核的数据但是可以通过中断, 系统调用等方式从用户态陷入内核态，但是内核态只是进程的一种状态, 与内核线程有本质区别
用户进程运行在用户空间上, 而一些通过共享资源实现的一组进程我们称之为线程组, Linux下内核其实本质上没有线程的概念, Linux下线程其实上是与其他进程共享某些资源的进程而已。但是我们习惯上还是称他们为线程或者轻量级进程
因此, Linux上进程分3种，内核线程（或者叫核心进程）、用户进程、用户线程, 当然如果更严谨的，你也可以认为用户进程和用户线程都是用户进程。

内核线程拥有 进程描述符、PID、进程正文段、核心堆栈

用户进程拥有 进程描述符、PID、进程正文段、核心堆栈 、用户空间的数据段和堆栈

用户线程拥有 进程描述符、PID、进程正文段、核心堆栈，同父进程共享用户空间的数据段和堆栈
---

https://coolshell.cn/articles/10249.html
https://www.zhihu.com/question/27844575/answer/38370294

http://laoar.net/blogs/250/
  
http://blog.csdn.net/daniel_ice/article/details/8146003
  
http://blog.csdn.net/yjzl1911/article/details/5629537

http://www.pandademo.com/2015/10/linux-process-and-thread-stack-size/

http://www.pandademo.com/2015/10/linux-process-and-thread-stack-size/embed/#?secret=iaqm21dSlH

https://www.zhihu.com/question/27844575
https://coolshell.cn/articles/4626.html
https://cloud.tencent.com/developer/article/1339562  
https://blog.csdn.net/gatieme/article/details/51481863
https://blog.csdn.net/gatieme/article/details/51892437
