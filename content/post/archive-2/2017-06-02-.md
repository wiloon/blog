---
title: 线程
author: w1100n
type: post
date: -001-11-30T00:00:00+00:00
draft: true
url: /?p=10461


---

抽象的实质是对问题的转换。我们可以把抽象应用于一个问题，把它转换成另一个（或许）更简单的问题来解决。解决了转换后的简单问题，就意味着解决了原有的困难问题。严格来说，一个抽象一定要保存原有问题的结构，同时去除无关细节。但是，由于我们生活的世界并没有什么东西是完全“严格”的，现实中使用的抽象有时会隐藏解决问题的关键细节，或者残留一些不该漏出来的东西。评价一个抽象的好坏，也就不止是看它能节省多少代码，和它的界面有多优美这么简单，同时还要看看在一个问题被抽象转换之后，留了下来的细节还能不能好好地解决它。

一般来说，在修复一个糟糕的抽象时，可以采取的策略分如下两类：

把造成问题的那部分抽象拿掉，直接露出底层的细节
换一个和底层兼容性更好的抽象模型

角色模型，通信进程（Communicating Sequential Processes, CSP），以及函数式编程（FP）

墨菲定律的变体：布劳尔技术惯性定律（已经成功的技术在新的，更好的技术出现时也会赖着不走）


https://coolshell.cn/articles/4626.html

死锁，
活锁，
优先级反转

程模型好就好在，它的资源分享: 共享变量
角色模型（Actor Model） 比线程模型好就好在，它的资源分享不像线程模型那样通过共享变量来进行。  角色模型中的资源分享只能通过特定的机制（消息传递）来进行。   

RMI TCP connection  
to feed a remote JMX client (in your case Java VisualVM) with data from JVM.    
https://stackoverflow.com/questions/40793580/what-is-rmi-tcp-connection




https://coolshell.cn/articles/10249.html
