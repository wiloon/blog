---
title: linux 文件空洞
author: wiloon
type: post
date: 2017-09-01T05:12:37+00:00
url: /?p=11081
categories:
  - Uncategorized

---
http://blog.csdn.net/shenlanzifa/article/details/44016537

我们知道lseek()系统调用可以改变文件的偏移量，但如果程序调用使得文件偏移量跨越了文件结尾，然后再执行I/O操作，将会发生什么情况？ read()调用将会返回0，表示文件结尾。令人惊讶的是，write()函数可以在文件结尾后的任意位置写入数据。在这种情况下，对该文件的下一次写将延长该文件，并在文件中构成一个空洞，这一点是允许的。从原来的文件结尾到新写入数据间的这段空间被成为文件空洞。调用write后文件结尾的位置已经发生变化。

在Linux系统之中，文件结束符EOF根本不是一个字符，而是当系统读取到文件结尾，所返回的一个信号值（也就是-1），至于系统怎么知道文件的结尾，资料上说是通过比较文件的长度。

文件空洞占用任何磁盘空间，直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。空洞的存在意味着一个文件名义上的大小可能要比其占用的磁盘存储总量要大（有时大出许多）。向文件空洞中写入字节，内核需要为其分配存储单元，即使文件大小不变，系统的可用磁盘空间也将减少。这种情况并不常见，但也需要了解。

下面看一个例子：（转自http://blog.csdn.NET/wangxiaoqin00007/article/details/6617801）
  
ls -l file 查看文件逻辑大小
  
du -c file 查看文件实际占用的存储块多少
  
od -c file 查看文件存储的内容

空洞文件就是有空洞的文件,在日常的常识中,我们使用的文件存放在硬盘分区上的时候,有多大的内容就会占用多大的空间,比如这个文本文件里面写有1000个asc字符,那么就会占用磁盘上1000B的存储空间,为了便于管理文件,文件系统都是按块大小来分配给文件的,假如这个文件系统一个块是4096的话,那么这个文件就会占用一个块的,无论实际的内容是1B还是4000B.如果我们有一个4MB的文件,那么它会在分区中占用:4MB/4096B=1000个块.
  
现在我们先做一个实际的无空洞文件来看看:
  
#dd if=/dev/urandom of=testfile1 bs=4096 count=1000
  
这个命令会从/dev/urandom文件复制1000个块,每块大小4096,到testfile1文件去.
  
好了,我们已经有了testfile1这么一个4M的文件了,里面填充了一些随机的内容,你可以more一下.
  
然后用ls -l查看这个文件的大小是4096000,用du -h testfile1来查看的话,文件占用的磁盘大小是4M,两者是一样的.

下来是我们的重点,空洞文件,假如我们有一个文件,它有4M的大小,但是它里边很大一部分都是没有存放数据的,这样可不可以呢?试一下:
  
#dd if=/dev/urandom of=testfile2 bs=4096 seek=999 count=1
  
这个命令跟前一个命令相似,不同的是,它其实复制了1个块的内容,前面的999个块都跳过了.
  
我们ls -l一下,发现文件的大小还是4096000,用du -h testfile2查看,占用的块大小是4K
  
我们发现,虽然文件是4M,但是实际在磁盘上只占用了4K的大小,这就是空洞文件的神奇之处.

实际中的空洞文件会在哪里用到呢?常见的场景有两个:
  
一是在下载电影的时候,发现刚开始下载,文件的大小就已经到几百M了.
  
二是在创建虚拟机的磁盘镜像的时候,你创建了一个100G的磁盘镜像,但是其实装起来系统之后,开始也不过只占用了3,4G的磁盘空间,如果一开始把100G都分配出去的话,无疑是很大的浪费.

然后讲一下底层的实现吧,其实这个功能关键得文件系统支持,貌似FAT就不可以吧,linux下一直都很好的支持这一特性,我们举个最简单的ext的例子吧,ext中记录文件实际内容的对应信息的东东是一个叫索引表的东西,里面有十几个条目,每个条目存放对应文件内容块的块号,这样就可以顺序找到对应的文件内容了,大家可能说,几M的一个文件,十几个项哪够啊,不必担心,一般索引表前面几个项目是直接指向文件内容的,如果这几个不够的话,往后的第一个项目不会指向文件内容块,而会指向一个存放项目的块,这样一下多出N个项目来,如果这样还不够,下面的那个是存放指向指向的项目,不好意思,我也绕晕了,总之,前面的是直接指向,下面这个是二级指向,再下面的是二级指向,以此类推,这样,文件系统就可以处理T数量级别的文件,看下图:

到了空洞文件这里呢,我们只需要把指向没有文件内容部分的索引项目置NULL就好了,这样就不会指向实际的数据块了,也不会占用磁盘空间了,就这么easy~
  
至于btrfs这些新一代文件系统呢,在空洞文件这里的原理跟ext还是类似的.
  
最后介绍一下linux对空洞文件的处理,经过我最近的一些测试所得:
  
在同一文件系统ext4下,cat一个空洞文件到新文件,新文件不再是空洞文件,cp一个空洞文件到新文件,新文件仍然是空洞文件.
  
在btrfs跟ext4之间做的结果同上面是一致的,但是在不同文件系统之间cp,因为不同文件系统分配的最小单元不同,所以du结果会不同.
  
在nfs的客户端下,在nfs目录下去cp,新文件仍然是空洞文件!!!但是cp会逐个的去比较文件的内容,所以,受网络状况搞得影响,过程有时候会很慢.