---
title: MySQL Innodb 锁
author: "-"
date: 2015-12-15T07:38:27+00:00
url: /?p=8558
categories:
  - Inbox
tags:
  - reprint
---
## MySQL Innodb 锁

InnoDB 发音为"in-no-db"
  
    行锁

    行锁的分类

    行锁从mode上分为X、S,type上进一步细分为以下类型: 

      LOCK_GAP: GAP锁,锁两个记录之间的GAP,防止记录插入；

      LOCK_ORDINARY: 官方文档中称为 "Next-Key Lock" ,锁一条记录及其之前的间隙,这是RR级别用的最多的锁,从名字也能看出来；

      LOCK_REC_NOT_GAP: 只锁记录；

      LOCK_INSERT_INTENSION: 插入意向GAP锁,插入记录时使用,是LOCK_GAP的一种特例。

    RC级别只有记录锁,没有 Next-Key Lock 和 GAP锁,因此存在幻读现象。

    行锁是加在记录上的锁,InnoDB中的记录是以B+树索引的方式组织在一起的,InnoDB的行锁实际是 index record lock,即对B+索引叶子节点的锁。索引可能有多个,因此操作一行数据时,有可能会加多个行锁在不同的B+树上。

在计算机科学中,锁是在执行多线程时用于强行限制资源访问的同步机制,即用于在并发控制中保证对互斥要求的满足。

在[数据库的锁机制][1]中介绍过,在DBMS中,可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。

## 行级锁

行级锁是MySQL中锁定粒度最细的一种锁,表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小,但加锁的开销也最大。行级锁分为**[`共享锁`][2]** 和 **[`排他锁`][2]**。

### 特点

开销大,加锁慢；会出现死锁；锁定粒度最小,发生锁冲突的概率最低,并发度也最高。

* * *

## 表级锁

表级锁是MySQL中锁定粒度最大的一种锁,表示对当前操作的整张表加锁,它实现简单,资源消耗较少,被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为**`表共享读锁` ([共享锁][2])**与**`表独占写锁` ([排他锁][2])**。

### 特点

开销小,加锁快；不会出现死锁；锁定粒度大,发出锁冲突的概率最高,并发度最低。

* * *

## 页级锁

页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快,但冲突多,行级冲突少,但速度慢。所以取了折衷的页级,一次锁定相邻的一组记录。BDB支持页级锁

### 特点

开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间,并发度一般

* * *

## MySQL常用存储引擎的锁机制

> MyISAM和MEMORY采用表级锁(table-level locking)

> BDB采用页面锁(page-level locking)或表级锁,默认为页面锁

> InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

* * *

## Innodb中的行锁与表锁

前面提到过,在Innodb引擎中既支持行锁也支持表锁,那么什么时候会锁住整张表,什么时候或只锁住一行呢？

InnoDB行锁是通过给索引上的索引项加锁来实现的,这一点MySQL与Oracle不同,后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着: **只有通过索引条件检索数据,InnoDB才使用行级锁,否则,InnoDB将使用表锁！**

在实际应用中,要特别注意InnoDB行锁的这一特性,不然的话,可能导致大量的锁冲突,从而影响并发性能。

* 在不通过索引条件查询的时候,InnoDB 确实使用的是表锁,而不是行锁。
* 由于 MySQL 的行锁是针对索引加的锁,不是针对记录加的锁,所以虽然是访问不同行 的记录,但是如果是使用相同的索引键,是会出现锁冲突的。应用设计的时候要注意这一点。
* 当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。
* 即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫 效率更高,比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查 SQL 的执行计划,以确认是否真正使用了索引。

* * *

## 行级锁与死锁

MyISAM中是不会产生死锁的,因为MyISAM总是一次性获得所需的全部锁,要么全部满足,要么全部等待。而在InnoDB中,锁是逐步获得的,就造成了死锁的可能。

在MySQL中,行级锁并不是直接锁记录,而是锁索引。索引分为主键索引和非主键索引两种,如果一条sql语句操作了主键索引,MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引,MySQL会先锁定该非主键索引,再锁定相关的主键索引。 在UPDATE、DELETE操作时,MySQL不仅锁定WHERE条件扫描过的所有索引记录,而且会锁定相邻的键值,即所谓的next-key locking。

当两个事务同时执行,一个锁住了主键索引,在等待其他相关索引。另一个锁定了非主键索引,在等待主键索引。这样就会发生死锁。

发生死锁后,InnoDB一般都可以检测到,并使一个事务释放锁回退,另一个获取锁完成事务。

* * *

**有多种方法可以避免死锁,这里只介绍常见的三种**

1. 如果不同程序会并发存取多个表,尽量约定以相同的顺序访问表,可以大大降低死锁机会。

2. 在同一个事务中,尽可能做到一次锁定所需要的所有资源,减少死锁产生概率；

3. 对于非常容易产生死锁的业务部分,可以尝试使用升级锁定颗粒度,通过表级锁定来减少死锁产生的概率；

InnoDB锁

### 获取InonoD行锁争用情况

  可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况:

                    1
                  
                  
                  
                    2
                  
                  
                  
                    3
                  
                  
                  
                    4
                  
                  
                  
                    5
                  
                  
                  
                    6
                  
                  
                  
                    7
                  
                  
                  
                    8
                  
                  
                  
                    9
                  
                  
                  
                    10
                  
                  
                  
                    11
                  
                
                
                
                  
                    
                      MySQL> show status like 'innodb_row_lock%';
                    
                    
                    
                      +-------------------------------+-------+
                    
                    
                    
                      | Variable_name | Value |
                    
                    
                    
                      +-------------------------------+-------+
                    
                    
                    
                      | Innodb_row_lock_current_waits | 0 |
                    
                    
                    
                      | Innodb_row_lock_time | 0 |
                    
                    
                    
                      | Innodb_row_lock_time_avg | 0 |
                    
                    
                    
                      | Innodb_row_lock_time_max | 0 |
                    
                    
                    
                      | Innodb_row_lock_waits | 0 |
                    
                    
                    
                      +-------------------------------+-------+
                    
                    
                    
                      5 rows in set (0.00 sec)
                    
                  
                
              
            
          
        
      
  
  
        如果发现争用比较严重,如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高,还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等,并分析锁争用的原因。
  
### InnoDB的行锁模式及加锁方法

  InnoDB实现了以下两种类型的行锁。

      共享锁 (s) : 允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁。
    
    
      排他锁 (Ｘ) : 允许获取排他锁的事务更新数据,阻止其他事务取得相同的数据集共享读锁和排他写锁。

  另外,为了允许行锁和表锁共存,实现多粒度锁机制,InnoDB还有两种内部使用的意向锁 (Intention Locks) ,这两种意向锁都是表锁。

  意向共享锁 (IS) : 事务打算给数据行共享锁,事务在给一个数据行加共享锁前必须先取得该表的IS锁。

  意向排他锁 (IX) : 事务打算给数据行加排他锁,事务在给一个数据行加排他锁前必须先取得该表的IX锁。

#### **InnoDB行锁模式兼容性列表**

    <colgroup> <col width="161" /> <col width="120" /> <col width="115" /> <col width="101" /> <col width="90" /></colgroup> 
      
        当前锁模式/是否兼容/请求锁模式
      
      
      
        X
      
      
      
        IX
      
      
      
        S
      
      
      
        IS
      
    
    
    
      
        X
      
      
      
        冲突
      
      
      
        冲突
      
      
      
        冲突
      
      
      
        冲突
      
    
    
    
      
        IX
      
      
      
        冲突
      
      
      
        兼容
      
      
      
        冲突
      
      
      
        兼容
      
    
    
    
      
        S
      
      
      
        冲突
      
      
      
        冲突
      
      
      
        兼容
      
      
      
        兼容
      
    
    
    
      
        IS
      
      
      
        冲突
      
      
      
        兼容
      
      
      
        兼容
      
      
      
        兼容
      
    
  

      如果一个事务请求的锁模式与当前的锁兼容,InnoDB就请求的锁授予该事务；反之,如果两者两者不兼容,该事务就要等待锁释放。


      意向锁是InnoDB自动加的,不需用户干预。对于UPDATE、DELETE和INSERT语句,InnoDB会自动给涉及及数据集加排他锁 (Ｘ) ；对于普通SELECT语句,InnoDB会自动给涉及数据集加排他锁 (Ｘ) ；对于普通SELECT语句,InnoDB不会任何锁；事务可以通过以下语句显示给记录集加共享锁或排锁。

  共享锁 (Ｓ) : SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE

  排他锁 (X) : SELECT * FROM table_name WHERE ... FOR UPDATE

      用SELECT .. IN SHARE MODE获得共享锁,主要用在需要数据依存关系时确认某行记录是否存在,并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作,则很有可能造成死锁,对于锁定行记录后需要进行更新操作的应用,应该使用SELECT ... FOR UPDATE方式获取排他锁。

### InnoDB行锁实现方式

      InnoDB行锁是通过索引上的索引项来实现的,这一点ＭySQL与Oracle不同,后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者: 只有通过索引条件检索数据,InnoDB才会使用行级锁,否则,InnoDB将使用表锁！


      在实际应用中,要特别注意InnoDB行锁的这一特性,不然的话,可能导致大量的锁冲突,从而影响并发性能。

### 间隙锁 (Next-Key锁)

      当我们用范围条件而不是相等条件检索数据,并请求共享或排他锁时,InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录,叫做"间隙(GAP)",InnoDB也会对这个"间隙"加锁,这种锁机制不是所谓的间隙锁 (Next-Key锁) 。


      举例来说,假如emp表中只有101条记录,其empid的值分别是1,2,...,100,101,下面的SQL: 


  
    
      SELECT * FROM emp WHERE empid > 100 FOR UPDATE
  


      是一个范围条件的检索,InnoDB不仅会对符合条件的empid值为101的记录加锁,也会对empid大于101 (这些记录并不存在) 的"间隙"加锁。


      InnoDB使用间隙锁的目的,一方面是为了防止幻读,以满足相关隔离级别的要求,对于上面的例子,要是不使用间隙锁,如果其他事务插入了empid大于100的任何记录,那么本事务如果再次执行上述语句,就会发生幻读；另一方面,是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响,以及不同隔离级别下InnoDB使用间隙锁的情况。


      很显然,在使用范围条件检索并锁定记录时,InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入,这往往会造成严重的锁等待。因此,在实际开发中,尤其是并发插入比较多的应用,我们要尽量优化业务逻辑,尽量使用相等条件来访问更新数据,避免使用范围条件。

### 什么时候使用表锁

      对于InnoDB表,在绝大部分情况下都应该使用行级锁,因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个另特殊事务中,也可以考虑使用表级锁。


  
    
      第一种情况是: 事务需要更新大部分或全部数据,表又比较大,如果使用默认的行锁,不仅这个事务执行效率低,而且可能造成其他事务长时间锁等待和锁冲突,这种情况下可以考虑使用表锁来提高该事务的执行速度。
    
    
      第二种情况是: 事务涉及多个表,比较复杂,很可能引起死锁,造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表,从而避免死锁、减少数据库因事务回滚带来的开销。
    
  


      当然,应用中这两种事务不能太多,否则,就应该考虑使用ＭyISAＭ表。


      在InnoDB下 ,使用表锁要注意以下两点。


       (１) 使用LOCK TALBES虽然可以给InnoDB加表级锁,但必须说明的是,表锁不是由InnoDB存储引擎层管理的,而是由其上一层ＭySQL Server负责的,仅当autocommit=0、innodb_table_lock=1 (默认设置) 时,InnoDB层才能知道MySQL加的表锁,ＭySQL Server才能感知InnoDB加的行锁,这种情况下,InnoDB才能自动识别涉及表级锁的死锁；否则,InnoDB将无法自动检测并处理这种死锁。


       (２) 在用LOCAK TABLES对InnoDB锁时要注意,要将AUTOCOMMIT设为0,否则ＭySQL不会给表加锁；事务结束前,不要用UNLOCAK TABLES释放表锁,因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK产不能释放用LOCAK TABLES加的表级锁,必须用UNLOCK TABLES释放表锁,正确的方式见如下语句。


      例如,如果需要写表t1并从表t读,可以按如下做: 


  
    
      
        
          
            
              1
            
            
            
              2
            
            
            
              3
            
            
            
              4
            
            
            
              5
            
          
          
          
            
              
                SET AUTOCOMMIT=0;
              
              
              
                LOCAK TABLES t1 WRITE, t2 READ, ...;
              
              
              
                [do something with tables t1 and here];
              
              
              
                COMMIT;
              
              
              
                UNLOCK TABLES;

### 关于死锁

      ＭyISAM表锁是deadlock free的,这是因为ＭyISAM总是一次性获得所需的全部锁,要么全部满足,要么等待,因此不会出现死锁。但是在InnoDB中,除单个SQL组成的事务外,锁是逐步获得的,这就决定了InnoDB发生死锁是可能的。


      发生死锁后,InnoDB一般都能自动检测到,并使一个事务释放锁并退回,另一个事务获得锁,继续完成事务。但在涉及外部锁,或涉及锁的情况下,InnoDB并不能完全自动检测到死锁,这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。需要说明的是,这个参数并不是只用来解决死锁问题,在并发访问比较高的情况下,如果大量事务因无法立即获取所需的锁而挂起,会占用大量计算机资源,造成严重性能问题,甚至拖垮数据库。我们通过设置合适的锁等待超时阈值,可以避免这种情况发生。


      通常来说,死锁都是应用设计的问题,通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句,绝大部分都可以避免。下面就通过实例来介绍几种死锁的常用方法。


       (１) 在应用中,如果不同的程序会并发存取多个表,应尽量约定以相同的顺序为访问表,这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同,发生死锁的机会就非常高！但如果以相同的顺序来访问,死锁就可能避免。


       (２) 在程序以批量方式处理数据的时候,如果事先对数据排序,保证每个线程按固定的顺序来处理记录,也可以大大降低死锁的可能。


       (３) 在事务中,如果要更新记录,应该直接申请足够级别的锁,即排他锁,而不应该先申请共享锁,更新时再申请排他锁,甚至死锁。


       (４) 在REPEATEABLE-READ隔离级别下,如果两个线程同时对相同条件记录用SELECT...ROR UPDATE加排他锁,在没有符合该记录情况下,两个线程都会加锁成功。程序发现记录尚不存在,就试图插入一条新记录,如果两个线程都这么做,就会出现死锁。这种情况下,将隔离级别改成READ COMMITTED,就可以避免问题。


       (５) 当隔离级别为READ COMMITED时,如果两个线程都先执行SELECT...FOR UPDATE,判断是否存在符合条件的记录,如果没有,就插入记录。此时,只有一个线程能插入成功,另一个线程会出现锁等待,当第１个线程提交后,第２个线程会因主键重出错,但虽然这个线程出错了,却会获得一个排他锁！这时如果有第３个线程又来申请排他锁,也会出现死锁。对于这种情况,可以直接做插入操作,然后再捕获主键重异常,或者在遇到主键重错误时,总是执行ROLLBACK释放获得的排他锁。

      尽管通过上面的设计和优化等措施,可以大减少死锁,但死锁很难完全避免。因此,在程序设计中总是捕获并处理死锁异常是一个很好的编程习惯。


      如果出现死锁,可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施。

<http://www.cnblogs.com/sliverdang/p/3163455.html>

Innodb具备的锁种类

1. 表锁 (MySQL提供的,跟存储引擎无关)

2. 行锁 (Innodb存储引擎实现)

二 Innodb内部实现的锁种类

1. 记录锁

对应Innodb的行锁,记录锁锁的是索引记录,不是具体的数据记录。

2. 间隙锁

锁定索引记录间隙的锁,确保索引记录的间隙不变,间隙锁是针对事务隔离等级是可重复读或以上级别而言的！

例如:  create table t1(id int, v1 int,v2 int, primary key(id), key \`idx_v1\` (\`v1\`)) engine=innodb;

数据行有以下几行:

id
  
v1
  
v2
  
间隙锁一般是针对非唯一索引而言的

上面的数据表中v1的索引区间有

(-∞,1)

(1,3)

(3,4)

(4,5)

(5,7)

(7,9)

(9,+∞)

假如更新v1=5的数据行,那么此时会在索引记录idx_v1加上间隙锁,会把5之前的区间锁定,锁定的区间是(4,5)和(5,7),也就是区间(4,7),同时找到v1=5的数据行的主键,在该记录上加上记录锁,锁定该行记录。

3. 后码锁

记录锁和间隙锁的结合,对于innodb中,更新非唯一索引记录时,会加上后码锁。如果更新记录为空,就不能加记录锁,此时只剩下间隙锁。多条更新语句可能导致不同事务中锁定的索引区间重复,导致插入失败。

例子 (事务隔离等级为可重复读,主要看一下后码锁是记录锁和间隙锁的结合)

transaction 1
  
transaction 2
  
BEGIN;
  
BEGIN;
  
update t1 set v2=1 where v1=6;(这句SQL会加上后码锁,但是v1=6的记录不存在,后码锁是记录锁和间隙锁组成的,此时只能加上间隙锁,会锁住idx_v1的索引区间是(5,7))
  
update t1 set v2=2 where v1=7;(这句SQL也是加上后码锁,v1=7的记录存在,后码锁是由记录锁和区间锁组成,首先会使用记录锁,锁定v1=7的主键,即id=7的记录行,同时会使用间隙锁,会锁住idx_v1的索引区间是(5,9))
  
INSERT INTO t1 set id=8, v1=6,v2=2;(v1=6在自己的idx_v1锁定的索引区间(5,7));
  
INSERT INTO t1 set id=9, v1=8,v2=2;(v1=8在自己的idx_v1锁定的索引区间(5,9));
  
锁等待
  
插入成功
  
插入成功
  
rollback;
  
rollback;

由此可以看出,一个索引区间是可以被多个间隙锁锁定的,更新不当的时候,会造成死锁。

其中在transaction 2中,如果"INSERT INTO t1 set id=9, v1=8,v2=2;"这条语句换成"INSERT INTO t1 set id=9, v1=6,v2=2;"就会造成死锁,因为两个间隙锁都锁定了(5,7)这个区间。

同时在transaction 2中,执行update语句的时候,已经在id=7的主键索引上加了记录锁,任何在其他事务(例如transaction 1)中尝试更新id=7的行,都会被挂起,直到transaction 2提交或回滚。

三  锁选择

执行更新类语句,像SELECT ... FOR UPDATE, UPDATE,DELETE语句

1. 如果更新条件没有索引,例如执行"SELECT * FROM t1 where v2=2 for update",那么此时更新操作会使用表锁。多条更新SQL语句在不同的事务中同时执行,先取得表锁的事务会将其他事务挂起,直到当前事务提交或回滚。

使用表锁的原因:

由于更新的数据没有索引,MySQL只能做扫表操作,扫表的时候,要阻止其他任何的更新操作,所以会上升为表锁。

2. 如果更新条件为索引字段,但并非唯一索引 (包括主键) ,例如执行"SELECT * FROM t1 where v1=1 for update",那么此时更新会使用后码锁。

使用后码锁的原因:

a)首先要保证在符合条件的记录上加上排他的记录锁,会锁定当前非唯一索引和这些满足条件的记录对应的主键索引；b)还要保证更新的索引记录区间不能插入新数据。

3. 如果更新条件字段为唯一索引,使用记录锁。

Innodb会根据唯一索引,找到记录的主键索引,将符合条件的主键索引和唯一索引加上记录锁。

说明: Innodb的索引结构

Innodb支持聚簇索引,但是聚簇索引只能是主键索引,并且每张表只能有一个聚簇索引,所谓聚簇索引,就是索引在物理存储上是顺序存放的。主键索引就是聚簇索引,主键索引的叶子节点存放的是记录的物理地址,根据主键索引可以直接访问记录内容。非主键索引在B-tree索引的叶子节点上存放的并不是记录的物理地址,而是主键索引的物理地址。

当给非唯一索引加上后码锁的时候 (例如更新非唯一主键索引对应的记录内容) ,Innodb会采用后码锁。首先将满足条件的非唯一索引对应的主键索引和满足条件的非唯一索引加上记录锁。然后会给非唯一索引加上间隙锁,将当前非唯一索引对应的索引区间加上间隙锁,禁止在该区间的任何INSERT操作。

四 间隙锁演示

说明: 加后码锁的时候,并未锁住间隙两端的记录,那么两端的记录是可以更新的,但是如果更新记录时会影响到间隙锁,那需要被挂起,等待间隙锁被释放。

transaction 3
  
transaction 4
  
BEGIN;
  
BEGIN;
  
SELECT * FROM t1 WHERE v1=5 FOR UPDATE;(加上间隙锁,锁定了idx_v1的索引区间是(4,7),同时会把满足条件的记录的主键索引上加上行锁)
  
UPDATE 类操作

UPDATE t1 set v2=2 WHERE v1=4;(OK,不会被挂起,间隙锁锁只锁间隙,而这条更新SQL并未影响idx_v1在区间(4,7)的间隙锁控制范围);

UPDATE t1 set v2=2 WHERE v1=7;(OK,不会被挂起)

UPDATE t1 set v2=2 WHERE v1=6;(OK,不会被挂起)

UPDATE t1 set v1=1 WHERE v1=4;(OK,不会被挂起,更新索引)

UPDATE t1 set v1=5 WHERE v1=4;(由于4,7区间被封锁,这个操作会被挂起)

UPDATE t1 set v1=8 WHERE v1=7;(OK,不会被挂起,更新索引)

UPDATE t1 set v1=1 WHERE v1=9;(OK,不会被挂起,因为条件和目的索引的值都不在封锁的区间)

UPDATE t1 set v1=5 WHERE v1=7;(由于4,7区间被封锁,这个操作会被挂起)

UPDATE t1 set v1=2 WHERE v1=7(这个操作会被挂起)

由上面这两组SQL可以看出来,间隙锁锁住的区间为4,7,当更新这两端的记录的时候,如果不改变区间的值,压根就跟区间索引没关系,那么更新操作就不会被间隙锁挂起。如果更新间隙锁区间的两端的索引值,且更新索引后的区间包含当前锁住的区间,那么可以更新成功。如果更新索引后,不能包含已经锁定的区间,那么更新操作会被挂起。

INSERT 类操作

INSERT INTO t1 set id=11, v1=5, v2=5;(挂起,transaction 3封闭的idx_v1间隙是(4,7),插入v1=5肯定会被挂起)

INSERT INTO t1 set id=11, v1=8,v2=8(OK,v1不在封锁区间);

主要看一下在封锁区间两端的插入情况

INSERT INTO t1 set id=4,v1=4,v2=2;(v1=4是封锁区间的左侧值,此操作会被挂起)

INSERT INTO t1 set id=0,v1=4,v2=2;(此操作OK,可以执行)

INSERT INTO t1 set id=6, v1=7,v2=2;(v1=7是封锁区间的右侧值,此操作会被挂起)

INSERT INTO t1 set id=8, v1=7,v2=2;(此操作OK,可以执行)

当往封边区间两端插入值的时候,需要看要插入的值的主键是否在封锁区间对应的主键的范围。

具体解释:

id
  
v1
  
v2
  
当插入左边界值时,即插入v1=4的时候,要求主键id的值需要在小于id=3的范围,当数据库中v1=4左侧值有多条记录的时候,插入的id小于其中最大的id即可。

当插入右界值时,即插入v1=7的时候,要求主键id值大于id=7的范围,当数据库中v1=7右侧值有多条记录的时候,插入的id大于其中最小的id即可。
  
ROLLBACK;
  
ROLLBACK;
  
在5.5中,information_schema 库中增加了三个关于锁的表 (MEMORY引擎) ；
  
innodb_trx ## 当前运行的所有事务
  
innodb_locks ## 当前出现的锁
  
innodb_lock_waits ## 锁等待的对应关系

<http://blog.sina.com.cn/s/blog_53e68b3b0101bjxi.html>

<http://www.cnblogs.com/chenqionghe/p/4845693.html>

<http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB%20%E9%94%81.html>

<http://MySQLlover.com/?p=416>

<http://MySQL.taobao.org/monthly/2016/01/01/>

<http://MySQL.taobao.org/monthly/>

<http://xiaobaoqiu.github.io/blog/2015/06/03/MySQL-innodbsi-suo/>

<https://liuzhengyang.github.io/2016/09/25/MySQLinnodb/>

<http://www.wiloon.com/wp-admin/post.php?post=8558&action=edit>

 [1]: http://www.hollischuang.com/archives/909
 [2]: http://www.hollischuang.com/archives/923
