---
title: 文件描述符/句柄, file descriptor
author: "-"
type: post
date: 2017-03-24T01:49:22+00:00
url: /?p=9913
categories:
  - OS

---
## 文件描述符（file descriptor）
在Linux系统中一切皆可以看成是文件，文件又可分为: 普通文件、目录文件、链接文件和设备文件。文件描述符是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。POSIX标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话

### 文件描述限制
在编写文件操作的或者网络通信的软件时，初学者一般可能会遇到"Too many open files"的问题。这主要是因为文件描述符是系统的一个重要资源，虽然说系统内存有多少就可以打开多少的文件描述符，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的10%（以KB来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用sysctl -a | grep fs.file-max命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用ulimit -n命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一，具体优化方式请查看http://blog.csdn.net/kumu_linux/article/details/7877770。

文件描述符合打开文件之间的关系
  
    每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。
  
    1. 进程级的文件描述符表
  
    2. 系统级的打开文件描述符表
  
    3. 文件系统的i-node表

进程级的描述符表的每一条目记录了单个文件描述符的相关信息。
  
    1. 控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即close-on-exec标志）
  
    2. 对打开文件句柄的引用

内核对所有打开的文件的文件维护有一个系统级的描述符表格（open file description table）。有时，也称之为打开文件表（open file table），并将表格中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示: 
  
    1. 当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）
  
    2. 打开文件时所使用的状态标识（即，open()的flags参数）
  
    3. 文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）
  
    4. 与信号驱动相关的设置
  
    5. 对该文件i-node对象的引用
  
    6. 文件类型（例如: 常规文件、套接字或FIFO）和访问权限
  
    7. 一个指针，指向该文件所持有的锁列表
  
    8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳

下图展示了文件描述符、打开的文件句柄以及i-node之间的关系，图中，两个进程拥有诸多打开的文件描述符。

在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用dup()、dup2()、fcntl()或者对同一个文件多次调用了open()函数而形成的。
  
    进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用fork()后出现的（即，进程A、B是父子进程关系），或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。
  
    此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了open()调用。同一个进程两次打开同一个文件，也会发生类似情况。

<ol start="4">
  <li>
    总结
     1. 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件
     2. 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。
     3. 要获取和修改打开的文件标志（例如: O_APPEND、O_NONBLOCK和O_ASYNC），可执行fcntl()的F_GETFL和F_SETFL操作，其对作用域的约束与上一条颇为类似。
     4. 文件描述符标志（即，close-on-exec）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符
  </li>
</ol>

### 查看进程打开文件描述符

```bash
#PID: 12222
ls /proc/12222/fd/ -l
lsof -p 12222
```

### 系统级别的最大打开文件数

```bash
sysctl -a | grep fs.file-max
```

### 用户级限制

```bash
ulimit -n
```

1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。
  
2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。

fd算是在某种程度上替代句柄吧；

Linux 有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。

3.http://tech.ddvip.com/2009-06/1244006580122204_11.html

在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符(File Descriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此 后用户操纵文件皆通过该句柄进行。

设计这么一个句柄的原因在于句柄可以防止用户随意读写操作系统内核的文件对象。无论是Linux还是Windows，文件句柄总是和内核的文件对象相关联的，但如何关联细节用户并不可见。内核可以通过句柄来计算出内核里文件对象的地址，但此能力并不对用户开放。

下面举一个实际的例子，在Linux中，值为0、1、2的fd分别代表标准输入、标准输出和标准错误输出。在程序中打开文件得到的fd从3开始增长。 fd具体是什么呢?在内核中，每一个进程都有一个私有的"打开文件表"，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象。而fd，就是这 个表的下标。当用户打开一个文件时，内核会在内部生成一个打开文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标 作为fd。由于这个表处于内核，并且用户无法访问到，因此用户即使拥有fd，也无法得到打开文件对象的地址，只能够通过系统提供的函数来操作。

在C语言里，操纵文件的渠道则是FILE结构，不难想象，C语言中的FILE结构必定和fd有一对一的关系，每个FILE结构都会记录自己唯一对应的fd。
  
句柄 http://zh.wikipedia.org/wiki/%E5%8F%A5%E6%9F%84

在程序设计 中,句柄是一种特殊的智能指针 。当一个应用程序 要引用其他系统(如数据库、操作系统 )所管理的内存 块或对象 时，就要使用句柄。

句柄与普通指针 的区别在于，指针包含的是引用对象 的内存地址 ，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址 上。这种间接访问对象 的模式增强了系统对引用对象 的控制。（参见封装 )。

在上世纪80年代的操作系统（如Mac OS 和Windows ）的内存管理 中，句柄被广泛应用。Unix 系统的文件描述符 基本上也属于句柄。和其它桌面环境 一样，Windows API 大量使用句柄来标识系统中的对象 ，并建立操作系统与用户空间 之间的通信渠道。例如，桌面上的一个窗体由一个HWND 类型的句柄来标识。

如今，内存 容量的增大和虚拟内存 算法使得更简单的指针 愈加受到青睐，而指向另一指针的那类句柄受到冷淡。尽管如此，许多操作系统 仍然把指向私有对象 的指针以及进程传递给客户端 的内部数组 下标称为句柄。

http://www.blogjava.net/shijian/archive/2012/04/06/373463.html
  
http://blog.csdn.net/cywosp/article/details/38965239
  
————————————————
  
版权声明: 本文为CSDN博主「cywosp」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
  
原文链接: https://blog.csdn.net/cywosp/article/details/38965239