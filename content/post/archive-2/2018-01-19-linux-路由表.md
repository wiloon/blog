---
title: 路由表 routing table
author: wiloon
type: post
date: 2018-01-19T02:05:40+00:00
url: /?p=11757
categories:
  - Uncategorized

---
### archlinux

```bash
ip r
ip route show
ip route list
ip route show table all

ip route add DESTINATION [via NEXT_HOP] [src SOURCE_ADDRESS] [dev DEVICE]
 ip route add 192.168.1.0/24 via 172.16.1.106
如果网卡配置有多个ip时可以指定数据包从哪个网卡出去

# ip route add 192.168.1.0/24 src 172.16.1.106 dev eth1

 ip route del 192.168.0.1/24
```

```bash
ip r
```

```bash[root@dell ~]# ip r|column -t
default          via  192.168.50.1  dev    wlp9s0b1  proto  dhcp  src  192.168.50.244  metric  1024
10.88.0.0/16     dev  cni-podman0   proto  kernel    scope  link  src  10.88.0.1               
10.89.0.0/24     dev  cni-podman1   proto  kernel    scope  link  src  10.89.0.1               
192.168.50.0/24  dev  wlp9s0b1      proto  kernel    scope  link  src  192.168.50.244          
192.168.50.1     dev  wlp9s0b1      proto  dhcp      scope  link  src  192.168.50.244  metric  1024
```

via ADDRESS &#8212; the address of nexthop router.
  
dev NAME &#8212; the output device name.
  
src ADDRESS &#8212; the source address to prefer using when sending to the destinations covered by route prefix.
  
scope SCOPE_VAL &#8212; scope of the destinations covered by the route prefix.
  
protocol RTPROTO &#8212; routing protocol identifier of this route.

ip rule 命令：
  
Usage: ip rule [ list | add | del ] SELECTOR ACTION （add 添加；del 删除； llist 列表）
  
SELECTOR := \[ from PREFIX 数据包源地址\] \[ to PREFIX 数据包目的地址\] \[ tos TOS 服务类型\]\[ dev STRING 物理接口\] \[ pref NUMBER \] \[fwmark MARK iptables 标签\]
  
ACTION := \[ table TABLE_ID 指定所使用的路由表\] \[ nat ADDRESS 网络地址转换\][ prohibit 丢弃该表| reject 拒绝该包| unreachable 丢弃该包]
  
[ flowid CLASSID ]
  
TABLE_ID := [ local | main | default | new | NUMBER ]
  
例子：

ip rule add from 192.203.80/24 table inr.ruhep prio 220 通过路由表 inr.ruhep 路由来自源地址为192.203.80/24的数据包 
  
ip rule add from 193.233.7.83 nat 192.203.80.144 table 1 prio 320 把源地址为193.233.7.83的数据报的源地址转换为192.203.80.144，并通过表1进行路由 
  
————————————————
  
版权声明：本文为CSDN博主「zqixiao_09」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
  
原文链接：https://blog.csdn.net/zqixiao_09/article/details/53327074

路由表是指路由器或者其他互联网网络设备上存储的一张路由信息表，该表中存有到达特定网络终端的路径，在某些情况下，还有一些与这些路径相关的度量。

路由表中只存储网络信息而不是主机信息，这样可以大大简化路由表。
  
路由表中包含一系列被称为路由的规则，可用于判断网络流量的导向目的地。

Let&#8217;s interpret the output above by starting with the second line. This line says that packets sent to any IP address within the subnetwork 192.168.1.0/24 must be sent through the network interface wlan0 (a wireless network ínterface) with 192.168.1.100 as the source IP address, which in this case is the IP address assigned to wlan0 via DHCP. The other parts are not so interesting: proto kernel means this entry in the routing table was created by the kernel during autoconfiguration, while scope link means the destination IP addresses within 192.168.1.0/24 are valid only on the device wlan0.

The first line says that the default route for any packet (i.e., the route which is taken by a packet when no other route applies) is through the network device wlan0 via the default gateway (the router) which has the IP address 192.168.1.1. Figure 1 shows this network scheme.

The first column is the <Destination> subnet with the "default&#8221; being a wildcard for everything else. The "via&#8221; fragment points to the <Gateway> however when it is missing it indicates that that network is connected directly and instead it describes a source address.

The <Metric> column translates to the number of hops required to reach the destination and is used to determine which route shall be preferred when there are more than one route available for a specific destination. Since it reassembles the concept of distance the lower it&#8217;s value is the better.

The <Metric> value can be set manually however when NetworkManager creates a connection the following defaults are applied:

Ethernet is preferred over WiFi
  
WiFi is preferred over WWAN

https://diego.assencio.com/?index=d71346b8737ee449bb09496784c9b344

### deprecated net-tools command

查看 Linux 内核路由表
  
使用下面的 route 命令可以查看 Linux 内核路由表。
  
route
  
route -n
  
-c 显示更多信息
  
-n 不解析名字
  
-v 显示详细的处理信息
  
-F 显示发送信息
  
-C 显示路由缓存
  
-f 清除所有网关入口的路由表。
  
-p 与 add 命令一起使用时使路由具有永久性。

Destination Gateway Genmask Flags Metric Ref Use Iface
  
192.168.0.0 * 255.255.255.0 U 0 0 0 eth0
  
169.254.0.0 * 255.255.0.0 U 0 0 0 eth0
  
default 192.168.0.1 0.0.0.0 UG 0 0 0 eth0
  
route 命令的输出项说明

输出项说明
  
Destination 目标网段或者主机
  
Gateway 网关地址，”*” 表示目标是本主机所属的网络，不需要路由
  
Genmask 网络掩码
  
Flags 标记。一些可能的标记如下：

U — 路由是活动的
  
H — 目标是一个主机
  
G — 路由指向网关
  
R — 恢复动态路由产生的表项
  
D — 由路由的后台程序动态地安装
  
M — 由路由的后台程序修改
  
! — 拒绝路由

Metric 路由距离，到达指定网络所需的中转数（linux 内核中没有使用）
  
Ref 路由项引用次数（linux 内核中没有使用）
  
Use 此路由项被路由软件查找的次数
  
Iface 该路由表项对应的输出接口

## 3 种路由类型

### 主机路由

主机路由是路由选择表中指向单个IP地址或主机名的路由记录。主机路由的Flags字段为H。例如，在下面的示例中，本地主机通过IP地址192.168.1.1的路由器到达IP地址为10.0.0.10的主机。

Destination Gateway Genmask Flags Metric Ref Use Iface
  
&#8212;&#8212;&#8212;- &#8212;&#8212;- &#8212;&#8212;- &#8212;- &#8212;&#8212; &#8212; &#8212; &#8212;&#8211;
  
10.0.0.10 192.168.1.1 255.255.255.255 UH 0 0 0 eth0

网络路由
  
网络路由是代表主机可以到达的网络。网络路由的Flags字段为N。例如，在下面的示例中，本地主机将发送到网络192.19.12的数据包转发到IP地址为192.168.1.1的路由器。

Destination Gateway Genmask Flags Metric Ref Use Iface
  
&#8212;&#8212;&#8212;- &#8212;&#8212;- &#8212;&#8212;- &#8212;- &#8212;- &#8212; &#8212; &#8212;&#8211;
  
192.19.12 192.168.1.1 255.255.255.0 UN 0 0 0 eth0
  
默认路由
  
当主机不能在路由表中查找到目标主机的IP地址或网络路由时，数据包就被发送到默认路由（默认网关）上。默认路由的Flags字段为G。例如，在下面的示例中，默认路由是IP地址为192.168.1.1的路由器。

Destination Gateway Genmask Flags Metric Ref Use Iface
  
&#8212;&#8212;&#8212;- &#8212;&#8212;- &#8212;&#8212;- &#8212;- &#8212;&#8212; &#8212; &#8212; &#8212;&#8211;
  
default 192.168.1.1 0.0.0.0 UG 0 0 0 eth0

设置包转发
  
在 CentOS 中默认的内核配置已经包含了路由功能，但默认并没有在系统启动时启用此功能。开启 Linux的路由功能可以通过调整内核的网络参数来实现。要配置和调整内核参数可以使用 sysctl 命令。例如：要开启 Linux内核的数据包转发功能可以使用如下的命令。

# sysctl -w net.ipv4.ip_forward=1

这样设置之后，当前系统就能实现包转发，但下次启动计算机时将失效。为了使在下次启动计算机时仍然有效，需要将下面的行写入配置文件/etc/sysctl.conf。

# vi /etc/sysctl.conf

net.ipv4.ip_forward = 1
  
用户还可以使用如下的命令查看当前系统是否支持包转发。

# sysctl net.ipv4.ip_forward

ip rule add from 10.1.1.0/24 table TR1
  
ip rule add iff eth0 table RT2
         
如上，第一条命令创建了基于源地址路由的一条策略，这个策略使用了RT1这个路由表，第二条命令创建了基于数据包入口的一个策略，这个策略使用了RT2这个路由表。当被指定的路由表不存在时，相应的路由表将被创建。

第二步就是遍历这个路由表的fn\_zone，遍历是从最长前缀（子网掩码最长）的fn\_zone开始的，直到找到或出错为止。因为最长前缀才是最匹配的。假设有如下一个路由表：

dst nexthop dev
          
10.1.0.0/16 10.1.1.1 eth0
          
10.1.0.0/24 10.1.0.1 eth1

它会先找到第二条路由，然后选择10.1.0.1作为下一跳地址。但是，如果由第二步定位到的子网(fib_node)有多个路由，如下：

dst nexthop dev
          
10.1.0.0/24 10.1.0.1 eth1
          
10.1.0.0/24 10.1.0.2 eth1

到达同一个子网有两个可选的路由，仅凭目的子网无法确定，这时，它就需要更多的信息来确定路由的选择了，这就是用于查找路由的键值（structflowi）还包括其它信息（如TOS）的原因。这样，它才能定位到对应一个路由的一个fib\_alias实例。而它指向的fib\_info就是路由所需的信息了。
  
最后一步，如果内核被编译成支持多路径(multipath)路由，则fib\_info中有多个fin\_nh，这样，它还要从这个fib\_nh数组中选出最合适的一个fib\_nh，作为下一跳路由。

三、路由的插入与删除
         
路由表的插入与删除可以看看是路由查找的一个应用，插入与删除的过程本身也包含一个查找的过程，这两个操作都需要检查被插入或被删除的路由表项是否存在，插入一个已经存在的路由表项要做特殊的处理，而删除一个不存在的路由表项当然会出错。
         
下面看一个路由表插入的例子：

ip route add 10.0.1.0/24 nexthop via 10.0.1.1 weight 1
                                  
nexthop via 10.0.1.2 weight 2
                                     
table RT3

这个命令在内核中建立一条新的路由。它首先查找路由表RT3中的子网掩码长为24的fn\_zone，如果找不到，则创建一个fn\_zone。接着，继续查找子网为10.0.1的fib\_node，同样，如果不存在，创建一个fib\_node。然后它会在新建一个fib\_info结构，这个结构包含2个fib\_nh结构的数组（因为有两个nexthop），并根据用户空间传递过来的信息初始化这个结构，最后内核再创建一个fib\_alias结构（如果先前已经存在，则出错），并用fib\_nh来创始化相应的域，最后将自己链入fib_node的链中，这样就完成了路由的插入操作。

路由的删除操作是插入操作的逆过程，它包含一系列的查找与内存的释放操作，过程比较简单，这里就不再赘述了。

四、策略路由的一个简单应用
         
Linux系统在策略路由开启的时候将使用多个路由表，它不同于其它某些系统，在所有情况下都只使用单个路由表。虽然使用单个路由表也可以实现策略路由，但是如本文之前所提到的，使用多个路由表可以得到更好的性能，特别在一个大型的路由系统中。下面只通过简单的情况说明Linux下策略路由的应用。
  
如图2，有如下一个应用需求，其中网关服务器上有三个网络接口。接口1的IP为172.16.100.1，子网掩码为255.255.255.0，网关gw1为a.b.c.d，172.16.100.0/24这个网段的主机可以通过这个网关上网；接口2的IP是172.16.10.1，子网掩码同接口一，网关gw2为e.f.g.h，172.16.10.0/24这个网段的主机可以通过这个网关上网；接口0的IP为192.168.1.1，这个网段的主机由于网络带宽的需求需要通过e.f.g.h这个更快的网关路由出去。

图 2

步骤一：设置各个网络接口的IP，和默认网关：

ip addr add 172.16.100.1/24 dev eth1
  
ip route add default via a.b.c.d dev eth1
         
其它接口IP的设置和第一个接口一样，这时，如果没有其它设置，则所有的数据通过这个默认网关路由出去。

步骤二：使子网172.16.10.0/24可以通过gw2路由出去

       ip route add 172.16.10.0/24 via e.f.g.h dev eth2
    

步骤三：添加一个路由表

       echo   “250 HS_RT” >> /etc/iproute2/rt_tables
    

步骤四：使用策略路由使192.168.1.0/24网段的主机可以通过e.f.g.h这个网关上网

       ip rule add from 192.168.1.0/24 dev eth0 table HS_RT pref 32765
       ip route add default via e.f.g.h dev eth2
       iptables –t nat –A POSTROUTING –s 192.168.1.0/24 –j MASQUERADE
    

步骤五：刷新路由cache，使新的路由表生效

ip route flush cache
  
这样就可以实现了以上要求的策略路由了，并且可以通过traceroute工具来检测上面的设置是否能正常工作。

===============================================================================

linux双网卡怎么设置我就不说了,我这里说的是linux双网卡的流量问题&#8230;
  
可能这个问题很偏们..你们也许用不上..我还是要说..

问题描述,一个linux主机,上面两个网卡..:)

route -n的输出是这样的.

Destination Gateway Genmask Flags Metric Ref Use Iface

61.132.43.128 0.0.0.0 255.255.255.192 U 0 0 0 eth1

127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo

0.0.0.0 61.132.43.134 0.0.0.0 UG 0 0 0 eth0

这里解释一下&#8230;第一行是说,你要访问61.132.43.128这个网段,掩码是255.255.255.192的话..从e
  
th1这个网卡出去..
  
第二行是关于本机的,访问自己从lo这个虚拟的本地网卡走..
  
第三行是说你要去任何地方的话..从网关61.132.43.134出去.并且网卡是eth0

到这里我们看到了..我们除了去61.132.43.128这个网络是从eth1走以外..去其他地方都是从eth0�
  
�&#8230;

这样是不是很浪费了双网卡??没错..是很浪费..因为不论你用那种监测工具查看流量..都是eth0有
  
..而其他网卡没有&#8230;天哪&#8230;为此我是煞费苦心..甚至怀疑网卡是不是坏了..因为在win2k上这种�
  
虑槭遣豢赡芊⑸�..:)

那我们怎么解决这个问题呢?有人也许会说给个不同网关让另一块网卡用其他网关不就可以..是这�
  
鍪强梢�..但是问题是我的ip都是在同一个网段..那来的不同网关.?网关就一个61.132.43.134&#8230;

还好linux系统给我们提供了一个很好的路由套件&#8212;iproute2

我们来熟悉一下..iproute2由几个常见的命令..
  
ip ro ls ip就是ip命令啦,ro就是route的所写,ls是list的缩写&#8230;
  
整个命令就是列出系统的路由表..这个可和route
  
-n的效果差不多..但是更为清楚系统的route是如何的..

我们来看看吧:

[root@localhost root]# ip ro ls

61.132.43.128/26 dev eth1 proto kernel scope link src 61.132.43.136

127.0.0.0/8 dev lo scope link

default via 61.132.43.134 dev eth0

是不是一样呢?由几个地方不同..第一条多了一个src,增加了对源数据包的选择,而且子网掩码也变
  
成/26的形式..(参考ip地址的书籍)
  
最后一个仍然是网关&#8230;

现在我们只要稍稍动手把从61.132.43.136出来的流量让他不要从eth0出去..然他走eth1
  
我们加一条自定义的路由表

ip ro add default via 61.132.43.134 table 200

这里只是加了一条默认路由到一个自定义的路由表200中,最大数值是255,但是你不要用255,因为那
  
是系统默认用了..你用200以下就可以.
  
具体的路由表在/etc/iproute2/rt_tables中

查看刚才建立的路由表可以用ip ro ls table 200

[root@localhost root]# ip ro ls table 200

default via 61.132.43.134 dev eth1

看到了吗?虽然我没有指定dev是什么.但是系统自动分配了一个eth1给这个路由表,因为eth0已经用
  
在主路由表中了..
  
这也说明了,的确不能在同一个路由表中由相同的网关..虽然可以设置,但是具体没什么作用.

然后我们要用一个规则把,匹配的数据包引导到刚刚建立的路由表中..:)

ip ru add from 61.132.43.136 table 200

这里ru是rule的缩写.from是一个匹配的动作.就是所源地址是61.132.43.136的包..请走自定义路�
  
杀�的设置..:)

查看一下

[root@localhost root]# ip ru ls

0: from all lookup local

32765: from 61.132.43.136 lookup 200

32766: from all lookup main

32767: from all lookup 253

ip ro flush cache

# linux 下 双网卡 同网段，可以把IP_FORWARD 打开，这样一个网卡down掉数据会从另外一个网卡出去

linux路由表
  
2010年08月18日 星期三 17:44
  
宏CONFIG\_IP\_MULTIPLE_TABLES表示路由策略，当定义了该宏,也即意味着内核配置了“路由策略”。产生的最大的不同就是内核可以使用多达256张FIB。其实，这256张FIB在内核中的表示是一个全局数组：
          
struct fib\_table *myfib\_tables[RT\_TABLE\_MAX+1];
  
而宏RT\_TABLE\_MAX定义如下：
          
enum rt\_class\_t
          
{
              
RT\_TABLE\_UNSPEC=0,
              
RT\_TABLE\_DEFAULT=253,
              
RT\_TABLE\_MAIN=254,
              
RT\_TABLE\_LOCAL=255,
              
_\_RT\_TABLE_MAX
          
};
          
#define RT\_TABLE\_MAX (_\_RT\_TABLE_MAX - 1)
      
我们可以看到，虽然这张表多达256项，但枚举类型rt\_class\_t给出的表示最常用的也就三项，在系统初始化时，由内核配置生成的路由表只有RT\_TABLE\_MAIN，RT\_TABLE\_LOCAL两张。
     
main表中存放的是路由类型为RTN\_UNICAST的所有路由项，即网关或直接连接的路由。在myfib\_add\_ifaddr函数中是这样添加main表项的：对于某个网络设备接口的一个IP地址，如果目的地址的网络号不是零网络（网络号与子网号全为零），并且它是primary地址，同时，它不是D类地址（网络号与子网号占32位）。最后一个条件是：它不是一个环回地址(device上有flagIFF\_LOOPBACK）。那么，就添加为main表项，如果是环回地址，则添加为local表的一个表项。
      
在我们的系统中，有两个已开启的网络设备接口eth0和lo，eth0上配置的primaryIP地址是172.16.48.2，所以，相应的，main表中就只有一项。为main表添加路由项的时候，该路由项的目的地址是子网内的所有主机（把主机号部分字节清零），而对应于lo，在local表中也有一项，其类型为RTN\_LOCAL(注：前一篇文章中的local表的hash8中的路由项表述有误，类型应该是RTN\_LOCAL，而不是RTN_BORADCAST)。
     
而其它的路由项全部归入local表，主要是广播路由项和本地路由项。在我们的系统环境下，local表共有7项，每个网络设备接口占三项。分别是本地地址（源跟目的地址一致），子网广播地址（主机号全为1)，子网广播地址（主机号为零)。再加上一个lo的RTN_LOCAL项。
      
现在我们再来看myfib\_add\_ifaddr函数的路由添加策略。对于一个传入的ip地址（结构structin\_ifaddr表示），如果它是secondary地址，首先要确保同一个网络设备接口上存在一个跟其同类型的primary地址(网络号与子网号完全一致），因为，路由项的信息中的源地址全是primary的，secondary地址其实没有实际使用，它不会在路由表中产生路由项。然后，向local表添加一项目的地址是它本身的，类型为RTN\_LOCAL的路由项；如果该ip地址结构中存在广播地址，并且不是受限广播地址(255.255.255.255)，那么向local表添加一个广播路由项；然后，对符合加入main表的条件进行判断，如果符合，除了加入main表，最后，如果不是D类地址，还要加入两个广播地址（其实，已经跟前面有重叠，很多情况下不会实际触发加入的动作，只要记住，一个ip地址项对应最多有两个广播地址就可以了）。

多路由表（multiple Routing Tables）

　　传统的路由算法是仅使用一张路由表的。但是在有些情形底下，我们是需要使用多路由表的。例如一个子网通过一个路由器与外界相连，路由器与外界有两条线路相连，其中一条的速度比较快，一条的速度比较慢。对于子网内的大多数用户来说对速度并没有特殊的要求，所以可以让他们用比较慢的路由；但是子网内有一些特殊的用户却是对速度的要求比较苛刻，所以他们需要使用速度比较快的路由。如果使用一张路由表上述要求是无法实现的，而如果根据源地址或其它参数，对不同的用户使用不同的路由表，这样就可以大大提高路由器的性能。

　　规则（rule）

　　规则是策略性的关键性的新的概念。我们可以用自然语言这样描述规则，例如我门可以指定这样的规则：

　　规则一：“所有来自192.16.152.24的IP包，使用路由表10， 本规则的优先级别是1500”

　　规则二：“所有的包，使用路由表253，本规则的优先级别是32767”

　　我们可以看到，规则包含3个要素：

　　什么样的包，将应用本规则（所谓的SELECTOR，可能是filter更能反映其作用）；

　　符合本规则的包将对其采取什么动作（ACTION），例如用那个表；

　　本规则的优先级别。优先级别越高的规则越先匹配（数值越小优先级别越高）。

　　策略性路由的配置方法

　　传统的linux下配置路由的工具是route，而实现策略性路由配置的工具是iproute2工具包。这个软件包是由Alexey Kuznetsov开发的，软件包所在的主要网址为ftp://ftp.inr.ac.ru/ip-routing/。
  
这里简单介绍策略性路由的配置方法，以便能更好理解第二部分的内容。详细的使用方法请参考Alexey Kuznetsov写的 ip-cfref文档。策略性路由的配置主要包括接口地址的配置、路由的配置、规则的配置。

　　接口地址的配置IP Addr

　　对于接口的配置可以用下面的命令进行：

Usage: ip addr [ add | del ] IFADDR dev STRING

　　例如：

router># ip addr add 192.168.0.1/24 broadcast 192.168.0.255 label eth0 dev eth0

　　上面表示，给接口eth0赋予地址192.168.0.1 掩码是255.255.255.0(24代表掩码中1的个数)，广播地址是192.168.0.255

　　路由的配置IP Route

　　Linux最多可以支持255张路由表，其中有3张表是内置的：

　　表255 本地路由表（Local table） 本地接口地址，广播地址，已及NAT地址都放在这个表。该路由表由系统自动维护，管理员不能直接修改。

　　表254 主路由表（Main table） 如果没有指明路由所属的表，所有的路由都默认都放在这个表里，一般来说，旧的路由工具（如route）所添加的路由都会加到这个表。一般是普通的路由。

　　表253 默认路由表 （Default table） 一般来说默认的路由都放在这张表，但是如果特别指明放的也可以是所有的网关路由。

　　表 0 保留

　　路由配置命令的格式如下：

Usage: ip route list SELECTOR
  
ip route { change | del | add | append | replace | monitor } ROUTE

　　如果想查看路由表的内容，可以通过命令：

　　ip route list table table_number

　　对于路由的操作包括change、del、add 、append 、replace 、 monitor这些。例如添加路由可以用：

router># ip route add 0/0 via 192.168.0.4 table main
  
router># ip route add 192.168.3.0/24 via 192.168.0.3 table 1

第一条命令是向主路由表（main table）即表254添加一条路由，路由的内容是设置192.168.0.4成为网关。

　　第二条命令代表向路由表1添加一条路由，子网192.168.3.0（子网掩码是255.255.255.0）的网关是192.168.0.3。

　　在多路由表的路由体系里，所有的路由的操作，例如网路由表添加路由，或者在路由表里寻找特定的路由，需要指明要操作的路由表，所有没有指明路由表，默认是对主路由表（表254）进行操作。而在单表体系里，路由的操作是不用指明路由表的。

===============================================================================

===============================================================================

http://www.policyrouting.org/iproute2.doc.html#ss9.5
  
http://www.cnblogs.com/gunl/archive/2010/09/14/1826234.html
  
http://www.cnblogs.com/peida/archive/2013/03/05/2943698.html
  
https://blog.csdn.net/younger_china/article/details/72081779