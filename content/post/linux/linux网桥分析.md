---
title: Linux网桥分析
author: "-"
date: 2011-12-04T06:59:11+00:00
url: /?p=1775
categories:
  - Network

tags:
  - reprint
---
## Linux网桥分析
<http://hi.baidu.com/zkheartboy/blog/item/9d1c392e42b44a544ec2263b.html>

一、网桥原理
  
网桥 (Bridge) 也称桥接器，是连接两个局域网的存储转发设备，用它可以完成具有相同或相似体系结构网络系统的连接。一般情况下，被连接的网络系统都具有相同的逻辑链路控制规程 (LLC) ，但媒体访问控制协议 (MAC) 可以不同。
  
网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个"低层的路由器" (路由器工作在网络层，根据网络地址如IP地址进行转发) 。 远程网桥通过一个通常较慢的链路 (如电话线) 连接两个远程LAN，对本地网桥而言，性能比较重要，而对远程网桥而言，在长距离上可正常运行是更重要的。

二、Linux网桥的使用
  
要配置网桥，要网桥的配置工具bridge-utils。源代码可以在http://bridge.sourceforge.net/bridge-utils/ 下载。编译成功之后，生成网桥配置的工具名称为brctl。

配置说明: 
  
有五台主机。其中一台主机装有linux ，安装了网桥模块，而且有四块物理网卡，分别连接同一网段的其他主机。我们希望其成为一个网桥，为其他四台主机(IP分别为192.168.1.2 ，192.168.1.3，192.168.1.4，192.168.1.5) 之间转发数据包。同时，为了方便管理，希望网桥能够有一个IP (192.168.1.1) ，那样管理员就可以在192.168.1.0/24网段内的主机上telnet到网桥，对其进行配置，实现远程管理。

我们为这个逻辑网段一个名称，br_192。首先需要配置这样一个逻辑网段。

# brctl addbr br_192 (建立一个逻辑网段，名称为br_192)

实际上，我们可以把逻辑网段192.168.1.0/24看作使一个VLAN ，而br_192则是这个VLAN的名称。

建立一个逻辑网段之后，我们还需要为这个网段分配特定的端口。在Linux中，一个端口实际上就是一个物理网卡。而每个物理网卡的名称则分别为 eth0，eth1，eth2，eth3。我们需要把每个网卡一一和br_192这个网段联系起来，作为br_192中的一个端口。

# brctl addif br_192 eth0 (让eth0成为br_192的一个端口)
  
# brctl addif br_192 eth1 (让eth1成为br_192的一个端口)
  
# brctl addif br_192 eth2 (让eth2成为br_192的一个端口)
  
# brctl addif br_192 eth3 (让eth3成为br_192的一个端口)

网桥的每个物理网卡作为一个端口，运行于混杂模式，而且是在链路层工作，所以就不需要IP了。

# ifconfig eth0 0.0.0.0
  
# ifconfig eth1 0.0.0.0
  
# ifconfig eth2 0.0.0.0
  
# ifconfig eth3 0.0.0.0

然后给br_192的虚拟网卡配置IP: 192.168.1.1。那样就能远程管理网桥。

# ifconfig br_192 192.168.1.1

给br_192配置了IP之后，网桥就能够工作了。192.168.1.0/24网段内的主机都可以telnet到网桥上对其进行配置。

以上配置的是一个逻辑网段，实际上Linux网桥也能配置成多个逻辑网段(相当于交换机中划分多个VLAN)。具体的方法可以参考bridge-util中的HOWTO

三、Linux网桥分析

首先了解网桥处理包遵循着以下几条原则: 

1 在一个接口上接收到的包不会再在那个接口上发送这个数据包。
  
2 每个接收到的数据包都要学习其源MAC地址。
  
3 如果数据包是多播包或广播包，则要在同一个网段中除了接收端口外的其他所有端口发送这个数据包，如果上层协议栈对多播包感兴趣，则需要把数据包提交给上层协议栈。
  
4 如果数据包的目的MAC地址不能在CAM表中找到，则要在同一个网段中除了接收端口外的其他所有端口发送这个数据包。
  
5 如果能够在CAM表中查询到目的MAC地址，则在特定的端口上发送这个数据包，如果发送端口和接收端口是同一端口，则不发送。

网桥以混杂方式工作，它接收与之连接的所有LAN传送的每一帧。当一帧到达时，网桥必须决定将其丢弃还是转发。如果要转发，则必须决定发往哪个LAN。这需要通过查询网桥中一张大型散列表里的目的地址而作出决定。该表可列出每个可能的目的地，以及它属于哪一条输出线路(LAN)。在插入网桥之初，所有的散列表均为空。由于网桥不知道任何目的地的位置，因而采用扩散算法(flooding algorithm): 把每个到来的、目的地不明的帧输出到连在此网桥的所有LAN中 (除了发送该帧的LAN) 。随着时间的推移，网桥将了解每个目的地的位置。一旦知道了目的地位置，发往该处的帧就只放到适当的LAN上，而不再散发。

网桥采用的算法是逆向学习法(backward learning)。网桥按混杂的方式工作，故它能看见所连接的任一LAN上传送的帧。查看源地址即可知道在哪个LAN上可访问哪台机器，于是在散列表中添上一项。

当计算机和网桥加电、断电或迁移时，网络的拓扑结构会随之改变。为了处理动态拓扑问题，每当增加散列表项时，均在该项中注明帧的到达时间。每当目的地已在表中的帧到达时，将以当前时间更新该项。这样，从表中每项的时间即可知道该机器最后帧到来的时间。网桥中有一个进程定期地扫描散列表，清除时间早于当前时间若干分钟的全部表项。于是，如果从LAN上取下一台计算机，并在别处重新连到LAN上的话，那么在几分钟内，它即可重新开始正常工作而无须人工干预。这个算法同时也意味着，如果机器在几分钟内无动作，那么发给它的帧将不得不散发，一直到它自己发送出一帧为止。

在Linux内核网桥的实现中，一个逻辑网段用net_bridge结构体表示。一个逻辑网段需要保留的信息有: 

1 本逻辑网段中所有的端口(port_list)
  
每个端口用net_bridge_port结构体来表示，从net_bridge_port结构体中可以看出，它主要有:

1 逻辑网段中的下一个端口(next)
  
2 本端口所属的逻辑网段(br)
  
3 本端口所指向的物理网卡 (dev) 
  
4 本端口在网桥中的编号(port_no)
  
5 用于生成树管理的信息
  
一个逻辑网段中可以具有很多个端口，所有的端口都挂在以port_list为链表头的链表上。

2 本网段中CAM表 (hash[BR_HASH_SIZE]) 
  
CAM表中的每个项用net_bridge_fdb_entry结构体代表，每项中有: 

1 用于CAM表连接的链表指针 (next_hash，pprev_hash) 
  
2 此项当前的引用计数 (use_count) 
  
3 MAC地址 (addr) 
  
4 此项所对应的端口 (dst) 
  
5 处理MAC超时 (ageing_timer) 
  
6 是否是本机的MAC地址 (is_local) 
  
7 是否是静态MAC地址 (is_static) 
  
一个逻辑网段中的所有表项形成一个CAM表，他们之间的组织关系是一个HASH链表。HASH链的个数为BR_HASH_SIZE (256) 。

3 本逻辑网段用于和外部通信的虚拟网络设备 (dev) 
  
Linux网桥可以在网桥上为每个逻辑网段配置一个IP，用于和外部通信。实际上这个IP不是配置在一个特定的物理网卡上面， 而是建立一个虚拟的网卡，虚拟网卡可以附在每个同一逻辑网段的物理网卡上，让这个网卡可以象所有的物理网卡一样工作。从而使网桥可以和外部通信。

4 本逻辑网段虚拟网卡的统计数据 (statistics) 
  
按照Linux网卡驱动的接口，一个网卡的统计信息是由每个网卡的私有数据处理的。一般的写法是用dev->priv来指向每个网卡的统计数据。网卡的get_stats方法就是用来读取统计数据。