---
author: "-"
date: "2021-04-18 12:04:24" 
title: "fork exec system()"

categories:
  - inbox
tags:
  - reprint
---
## "fork exec system()"
system()、exec()、fork()三个与进程有关的函数的比较
### 启动新进程 (system函数) 
system()函数可以启动一个新的进程。

int system (const char *string )

这个函数的效果就相当于执行sh –c string。

一般来说，使用system函数远非启动其他进程的理想手段，因为它必须用一个shell来启动需要的程序。这样对shell的安装情况，以及shell的版本依赖性很大。

system函数的特点: 

建立独立进程，拥有独立的代码空间，内存空间

等待新的进程执行完毕，system才返回。(阻塞)

### 替换进程映像 (exec函数) 
exec函数可以用来替换进程映像。执行exec系列函数后，原来的进程将不再执行，新的进程的PID、PPID和nice值与原先的完全一样。其实执行exec系列函数所发生的一切就是，运行中的程序开始执行exec调用中指定的新的可执行文件中的代码。

exec函数的特点: 

当进程调用一种exec函数时，源进程完全由新程序代换，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用另一个新程序替换了当前进程的正文、数据、堆和栈段。特别地，在原进程中已经打开的文件描述符，在新进程中仍将保持打开，除非它们的"执行时关闭标志" (close on exec flag) 被置位。任何在原进程中已打开的目录流都将在新进程中被关闭。

 

### 复制进程映像 (fork函数)   
fork函数
头文件

#include<unistd.h>  
#include<sys/types.h>  
函数原型

pid_t fork( void);  
返回值: 

若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1

关于fork函数的作用，《Linux程序设计》中是这样解释的: 

我们可以通过调用fork创建一个新进程。这个系统调用复制当前进程，在进程表中新建一个新的表项，新表项中的许多属性与当前进程是相同的。新进程几乎与元进程一模一样，执行的代码也完全相同，但是新进程有自己的数据空间、环境和文件描述符。

这个解释其实过于笼统，很多细节问题都没有说。下面就简单说一下调用fork时发生的一些细节问题。或者叫fork函数的特点: 

首先，现在的 UNIX 系统和 Linux 系统都采用写时复制技术 (COW: Copy On Write) 。使用这种技术，当调用 fork 函数时，新的进程只是拥有自己的虚拟内存空间，而没有自己的物理内存空间。 新进程共享源进程的物理内存空间。 而且新内存的虚拟内存空间几乎就是源进程虚拟内存空间的一个复制。

我们知道，进程空间可以简单地分为程序段 (正文段) 、数据段、堆和栈四部分 (简单这样理解) 。采用写时复制的fork函数，当执行完fork后的一定时间内，新的进程 (子进程) 和源进程的进程空间关系如下图: 

fork执行时，Linux 内核会为新的进程 P2 创建一个虚拟内存空间，而新的虚拟空间中的内容是对 P1 虚拟内存空间中的内容的一个拷贝。而 P2 和 P1 共享原来 P1 的物理内存空间。

当然要理解"写时复制"中，上图中所展示的状态是会发生变化的。什么时候回发生变化呢？就是，父子两个进程中任意一个进程对数据段、栈区、堆区进行写操作时，上图中的状态就会被打破，这个时候就会发生物理内存的复制，这也就是叫"写时复制"的原因。发生的状态转变如下: 

我们发现，P2有了属于自己的物理内存空间。值得注意的是，各个段之间发生的变化应当是独立的，也就是说，如果只有数据段发生了写操作那么就只有数据段进行写时复制。而堆、栈区域依然是父子进程共享。还有一个需要注意的是，正文段 (程序段) 不会发生写时复制，这是因为通常情况下程序段是只读的。子进程和父进程从fork之后，基本上就是独立运行，互不影响了。

此外需要特别注意的是，父子进程的文件描述符表也会发生写时复制。

还有一个叫vfork的函数，这个做法更加火爆，内核连子进程的虚拟地址空间结构也不创建了，直接共享了父进程的虚拟空间，当然了，这种做法就顺水推舟的共享了父进程的物理空间

system()、exec()、fork()函数比较
首先比较一下exec()函数和fork()。这两个函数一个是换药不换汤 (execl函数) ，另一个是换汤不换药 (fork函数) 。那么什么是汤、什么又是药呢？我们知道进程是个很复杂的东西。从task_struct 结构体的代码量上就可以看出来 (task_struct是Linux内核中用来描述进程的一个结构体，这个结构体光代码貌似就有好几屏) 。我们可以把进程的PID、PPID和nice值等看作是汤，而把进程空间 (简单理解就是正文段、数据段、堆、栈等) 看作是药。

exec()函数是换药不换汤，就是说执行exec函数后，并没有产生新的进程，也就是汤还是那些汤，进程的PID、PPID和nice值等没有发生变化。但是exec()函数却将药换了，也就是将进程空间换掉了，新的进程空间是为了执行新的程序所准备的，所以新的进程空间与原进程空间并没有什么关系。

fork()函数是换汤不换药，意思是执行fork()函数后，产生了新的进程，新的进程的PID、PPID与原来原来的进程不同，说明父子进程是两个不同的进程，但是fork并没有把药换掉，而是将药复制了一份给子进程。fork刚执行后的一段时间内，父子进程有着相同的状态 (进程空间中的东西都一样，因为fork采用"写时复制"，一开始父子进程共享物理内存空间) 。但是一旦父子进程中有一个进程试图修改进程空间，这时父子进程就各自拥有了各自的进程空间，简单地理解，从这一时刻器，父子进程就是两个独立的进程，谁都不会影响谁 (实际上还是有一定影响的，在这里可以忽略) ，父子进程之间的关联仅剩下它们共享的代码段了。

对于system函数，我们可以先看一下它的源代码: 

复制代码
int system(const char * cmdstring)
{
  pid_t pid;
  int status;
 
  if(cmdstring == NULL){
      
      return (1);
  }
 
 
  if((pid = fork())<0){
 
        status = -1;
  }
  else if(pid == 0){
    execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);
    -exit(127); //子进程正常执行则不会执行此语句
    }
  else{
        while(waitpid(pid, &status, 0) < 0){
          if(errno != EINTER){
            status = -1;
            break;
          }
        }
    }
    return status;
}
复制代码

我们看到system()函数实际上就是先执行了fork函数，然后新产生的子进程立刻执行了exec函数，我们前面说个fork函数换汤不换药，exec函数换药不换汤，那么system函数就是既换汤也换了药，也就是system函数会产生新进程，这就意味着新进程的PID、PPID等与原进程不同。system也会产生新的进程空间，而且新的进程空间是为新的程序准备的，所以和原进程的进程空间没有任何关系 (不像fork新进程空间是对原进程空间的一个复制) 。还要注意的是，system函数代码中else部分执行了wait函数，这就意味着，原进程会等待子进程执行完毕 (阻塞) 

最后还要注意的一个问题是关于文件描述符的。

exec函数执行后，原来打开的文件描述符依然存在。

fork函数执行后，原来打开的文件描述符会复制一份到新的进程中，之后两个进程之间的文件描述符就相对独立了。

system函数先执行fork函数，这之后两个进程的文件描述符就相对独立了。之后exec函数并不影响文件描述符。

###  Linux下Fork与Exec使用

一、引言

对于没有接触过Unix/Linux操作系统的人来说，fork是最难理解的概念之一: 它执行一次却返回两个值。fork函数是Unix系统最杰出的成就之一，它是七十年代UNIX早期的开发者经过长期在理论和实践上的艰苦探索后取得的成果，一方面，它使操作系统在进程管理上付出了最小的代价，另一方面，又为程序员提供了一个简洁明了的多进程方法。与DOS和早期的Windows不同，Unix/Linux系统是真正实现多任务操作的系统，可以说，不使用多进程编程，就不能算是真正的Linux环境下编程。

多线程程序设计的概念早在六十年代就被提出，但直到八十年代中期，Unix系统中才引入多线程机制，如今，由于自身的许多优点，多线程编程已经得到了广泛的应用。

下面，我们将介绍在Linux下编写多进程和多线程程序的一些初步知识。

二、多进程编程

什么是一个进程？进程这个概念是针对系统而不是针对用户的，对用户来说，他面对的概念是程序。当用户敲入命令执行一个程序的时候，对系统而言，它将启动一个进程。但和程序不同的是，在这个进程中，系统可能需要再启动一个或多个进程来完成独立的多个任务。多进程编程的主要内容包括进程控制和进程间通信，在了解这些之前，我们先要简单知道进程的结构。

2.1 Linux下进程的结构

Linux 下一个进程在内存里有三部分的数据，就是"代码段"、"堆栈段"和"数据段"。其实学过汇编语言的人一定知道，一般的CPU都有上述三种段寄存器，以方便操作系统的运行。这三个部分也是构成一个完整的执行序列的必要的部分。

"代码段"，顾名思义，就是存放了程序代码的数据，假如机器中有数个进程运行相同的一个程序，那么它们就可以使用相同的代码段。"堆栈段"存放的就是子程序的返回地址、子程序的参数以及程序的局部变量。而数据段则存放程序的全局变量，常数以及动态数据分配的数据空间 (比如用malloc之类的函数取得的空间) 。这其中有许多细节问题，这里限于篇幅就不多介绍了。系统如果同时运行数个相同的程序，它们之间就不能使用同一个堆栈段和数据段。

2.2 Linux下的进程控制

在传统的Unix环境下，有两个基本的操作用于创建和修改进程: 函数fork( )用来创建一个新的进程，该进程几乎是当前进程的一个完全拷贝；函数族exec( )用来启动另外的进程以取代当前运行的进程。Linux的进程控制和传统的Unix进程控制基本一致，只在一些细节的地方有些区别，例如在Linux系统中调用vfork和fork完全相同，而在有些版本的Unix系统中，vfork调用有不同的功能。由于这些差别几乎不影响我们大多数的编程，在这里我们不予考虑。

2.2.1 fork () 

fork在英文中是"分叉"的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork，就产生了另一个进程，于是进程就"分叉"了，所以这个名字取得很形象。下面就看看如何具体使用fork，这段程序演示了使用fork的基本框架: 

 1void main()
 2{
 3    int i;
 4    if ( fork() == 0 ) 
 5    {
 6       /* 子进程程序 */
 7       for ( i = 1; i <1000; i ++ ) 
 8          printf("This is child process\n");
 9    }
10    else 
11    {
12       /* 父进程程序*/
13       for ( i = 1; i <1000; i ++ ) 
14       printf("This is process process\n");
15    }
16}

程序运行后，你就能看到屏幕上交替出现子进程与父进程各打印出的一千条信息了。如果程序还在运行中，你用ps命令就能看到系统中有两个它在运行了。

那么调用这个fork函数时发生了什么呢？fork函数启动一个新的进程，前面我们说过，这个进程几乎是当前进程的一个拷贝: 子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现，这将是我们下面的内容。既然它们如此相象，系统如何来区分它们呢？这是由函数的返回值来决定的。对于父进程， fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps函数就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork () 下面的代码，而我们就是利用fork () 函数对父子进程的不同返回值用if...else...语句来实现让父子进程完成不同的功能，正如我们上面举的例子一样。我们看到，上面例子执行时两条信息是交互无规则的打印出来的，这是父子进程独立执行的结果，虽然我们的代码似乎和串行的代码没有什么区别。

读者也许会问，如果一个大程序在运行中，它的数据段和堆栈都很大，一次fork就要复制一次，那么fork的系统开销不是很大吗？其实UNIX自有其解决的办法，大家知道，一般CPU都是以"页"为单位来分配内存空间的，每一个页都是实际物理内存的一个映像，象INTEL的CPU，其一页在通常情况下是 4086字节大小，而无论是数据段还是堆栈段都是由许多"页"构成的，fork函数复制这两个段，只是"逻辑"上的，并非"物理"上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的" 页"从物理上也分开。系统在空间上的开销就可以达到最小。

下面演示一个足以"搞死"Linux的小程序，其源代码非常简单: 

1void main()
2{
3   for( ; ; )
4   {
5     fork();
6   }
7}

这个程序什么也不做，就是死循环地fork，其结果是程序不断产生进程，而这些进程又不断产生新的进程，很快，系统的进程就满了，系统就被这么多不断产生 的进程"撑死了"。当然只要系统管理员预先给每个用户设置可运行的最大进程数，这个恶意的程序就完成不了企图了。

 

2.2.2 exec( )函数族

下面我们来看看一个进程如何来启动另一个程序的执行。在Linux中要使用exec函数族。系统调用execve () 对当前进程进行替换，替换者为一个指定的程序，其参数包括文件名 (filename) 、参数列表 (argv) 以及环境变量 (envp) 。exec函数族当然不止一个，但它们大致相同，在 Linux中，它们分别是: execl，execlp，execle，execv，execve和execvp，下面我只以execlp为例，其它函数究竟与execlp有何区别，请通过manexec命令来了解它们的具体情况。

一个进程一旦调用exec类函数，它本身就"死亡"了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。 (不过exec类函数中有的还允许继承环境变量之类的信息。) 

那么如果我的程序想启动另一程序的执行但自己仍想继续运行的话，怎么办呢？那就是结合fork与exec的使用。下面一段代码显示如何启动运行其它程序: 

 1#include <errno.h>
 2#include <stdio.h>
 3#include <stdlib.h>
 4
 5char command[256];
 6void main()
 7{
 8   int rtn; /*子进程的返回数值*/
 9   while(1) {
10       /* 从终端读取要执行的命令 */
11       printf( ">" );
12       fgets( command, 256, stdin );
13       command[strlen(command)-1] = 0;
14       if ( fork() == 0 ) {/* 子进程执行此命令 */
15          execlp( command, NULL );
16          /* 如果exec函数返回，表明没有正常执行命令，打印错误信息*/
17          perror( command );
18          exit( errno );
19       }
20       else {/* 父进程， 等待子进程结束，并打印子进程的返回值 */
21          wait ( &rtn );
22          printf( " child process return %d\n", rtn );
23       }
24   }
25}

此程序从终端读入命令并执行之，执行完成后，父进程继续等待从终端读入命令。熟悉DOS和WINDOWS系统调用的朋友一定知道DOS/WINDOWS也有exec类函数，其使用方法是类似的，但DOS/WINDOWS还有spawn类函数，因为DOS是单任务的系统，它只能将"父进程"驻留在机器内再执行"子进程"，这就是spawn类的函数。WIN32已经是多任务的系统了，但还保留了spawn类函数，WIN32中实现spawn函数的方法同前述 UNIX中的方法差不多，开设子进程后父进程等待子进程结束后才继续运行。UNIX在其一开始就是多任务的系统，所以从核心角度上讲不需要spawn类函数。

在这一节里，我们还要讲讲system () 和popen () 函数。system () 函数先调用fork () ，然后再调用exec () 来执行用户的登录 shell，通过它来查找可执行文件的命令并分析参数，最后它么使用wait () 函数族之一来等待子进程的结束。函数popen () 和函数 system () 相似，不同的是它调用pipe () 函数创建一个管道，通过它来完成程序的标准输入和标准输出。这两个函数是为那些不太勤快的程序员设计的，在效率和安全方面都有相当的缺陷，在可能的情况下，应该尽量避免。

 

2.3 Linux下的进程间通信

详细的讲述进程间通信在这里绝对是不可能的事情，而且笔者很难有信心说自己对这一部分内容的认识达到了什么样的地步，所以在这一节的开头首先向大家推荐著名作者Richard Stevens的著名作品: 《Advanced Programming in the UNIX Environment》，它的中文译本《UNIX环境高级编程》已有机械工业出版社出版，原文精彩，译文同样地道，如果你的确对在Linux下编程有浓厚的兴趣，那么赶紧将这本书摆到你的书桌上或计算机旁边来。说这么多实在是难抑心中的景仰之情，言归正传，在这一节里，我们将介绍进程间通信最最初步和最最简单的一些知识和概念。

首先，进程间通信至少可以通过传送打开文件来实现，不同的进程通过一个或多个文件来传递信息，事实上，在很多应用系统里，都使用了这种方法。但一般说来，进程间通信 (IPC: InterProcess Communication) 不包括这种似乎比较低级的通信方法。Unix系统中实现进程间通信的方法很多，而且不幸的是，极少方法能在所有的Unix系统中进行移植 (唯一一种是半双工的管道，这也是最原始的一种通信方式) 。而 Linux 作为一种新兴的操作系统，几乎支持所有的Unix下常用的进程间通信方法: 管道、消息队列、共享内存、信号量、 socket 等等。下面我们将逐一介绍。

2.3.1 管道

管道是进程间通信中最古老的方式，它包括无名管道和有名管道两种，前者用于父进程和子进程间的通信，后者用于运行于同一台机器上的任意两个进程间的通信。

无名管道由pipe () 函数创建: 

#include <unistd.h>

int pipe(int filedis[2])；

参数filedis返回两个文件描述符: filedes[0]为读而打开，filedes[1]为写而打开。filedes[1]的输出是filedes[0]的输入。下面的例子示范了如何在父进程和子进程间实现通信。

 1 #define INPUT 0
 2 #define OUTPUT 1
 3 
 4 void main() {
 5    int file_descriptors[2];
 6    /*定义子进程号 */
 7    pid_t pid;
 8    char buf[256];
 9    int returned_count;
10    /*创建无名管道*/
11    pipe(file_descriptors);
12    /*创建子进程*/
13    if((pid = fork()) == -1) {
14       printf("Error in fork\n");
15       exit(1);
16    }
17    /*执行子进程*/
18    if(pid == 0) {
19       printf("in the spawned (child) process...\n");
20       /*子进程向父进程写数据，关闭管道的读端*/
21       close(file_descriptors[INPUT]);
22       write(file_descriptors[OUTPUT], "test data", strlen("test data"));
23       exit(0);
24    } else {
25       /*执行父进程*/
26       printf("in the spawning (parent) process...\n");
27       /*父进程从管道读取子进程写的数据，关闭管道的写端*/
28       close(file_descriptors[OUTPUT]);
29       returned_count = read(file_descriptors[INPUT], buf, sizeof(buf));
30       printf("%d bytes of data received from spawned process: %s\n",
31       returned_count, buf);
32    }
33 }

在Linux系统下，有名管道可由两种方式创建: 命令行方式mknod系统调用和函数mkfifo。下面的两种途径都在当前目录下生成了一个名为myfifo的有名管道: 

方式一: mkfifo("myfifo","rw");

方式二: mknod myfifo p

生成了有名管道后，就可以使用一般的文件I/O函数如open、close、read、write等来对它进行操作。下面即是一个简单的例子，假设我们已经创建了一个名为myfifo的有名管道。

 1/* 进程一: 读有名管道*/
 2#include <stdio.h>
 3#include <unistd.h>
 4void main() {
 5    FILE * in_file;
 6    int count = 1;
 7    char buf[80];
 8    in_file = fopen("mypipe", "r");
 9    if (in_file == NULL) {
10        printf("Error in fdopen.\n");
11        exit(1);
12    }
13    while ((count = fread(buf, 1, 80, in_file)) > 0)
14        printf("received from pipe: %s\n", buf);
15    fclose(in_file);
16}
17/* 进程二: 写有名管道*/
18#include <stdio.h>
19#include <unistd.h>
20void main() {
21    FILE * out_file;
22    int count = 1;
23    char buf[80];
24    out_file = fopen("mypipe", "w");
25    if (out_file == NULL) {
26        printf("Error opening pipe.");
27        exit(1);
28    }
29    sprintf(buf,"this is test data for the named pipe example\n");
30    fwrite(buf, 1, 80, out_file);
31    fclose(out_file);
32}
33

 

2.3.2 消息队列

消息队列用于运行于同一台机器上的进程间通信，它和管道很相似，事实上，它是一种正逐渐被淘汰的通信方式，我们可以用流管道或者 socket 的方式来取代它，所以，我们对此方式也不再解释，也建议读者忽略这种方式。

2.3.3 共享内存

共享内存是运行在同一台机器上的进程间通信最快的方式，因为数据不需要在不同的进程间复制。通常由一个进程创建一块共享内存区，其余进程对这块内存区进行读写。得到共享内存有两种方式: 映射/dev/mem设备和内存映像文件。前一种方式不给系统带来额外的开销，但在现实中并不常用，因为它控制存取的将是实际的物理内存，在Linux系统下，这只有通过限制Linux系统存取的内存才可以做到，这当然不太实际。常用的方式是通过shmXXX函数族来实现利用共享内存进行存储的。

首先要用的函数是shmget，它获得一个共享存储标识符。

#include <sys/types.h>

#include <sys/ipc.h>

#include <sys/shm.h>

int shmget(key_t key, int size, int flag);

这个函数有点类似大家熟悉的malloc函数，系统按照请求分配size大小的内存用作共享内存。Linux系统内核中每个IPC结构都有的一个非负整数的标识符，这样对一个消息队列发送消息时只要引用标识符就可以了。这个标识符是内核由IPC结构的关键字得到的，这个关键字，就是上面第一个函数的 key。数据类型key_t是在头文件sys/types.h中定义的，它是一个长整形的数据。在我们后面的章节中，还会碰到这个关键字。

当共享内存创建后，其余进程可以调用shmat () 将其连接到自身的地址空间中。

void *shmat(int shmid, void *addr, int flag);

shmid为shmget函数返回的共享存储标识符，addr和flag参数决定了以什么方式来确定连接的地址，函数的返回值即是该进程数据段所连接的实际地址，进程可以对此进程进行读写操作。

使用共享存储来实现进程间通信的注意点是对数据存取的同步，必须确保当一个进程去读取数据时，它所想要的数据已经写好了。通常，信号量被要来实现对共享存储数据存取的同步，另外，可以通过使用shmctl函数设置共享存储内存的某些标志位如SHM_LOCK、SHM_UNLOCK等来实现。

2.3.4 信号量

信号量又称为信号灯，它是用来协调不同进程间的数据对象的，而最主要的应用是前一节的共享内存方式的进程间通信。本质上，信号量是一个计数器，它用来记录对某个资源 (如共享内存) 的存取状况。一般说来，为了获得共享资源，进程需要执行下列操作: 

 (1)  测试控制该资源的信号量。

 (2)  若此信号量的值为正，则允许进行使用该资源。进程将进号量减1。

 (3)  若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于0，进程被唤醒，转入步骤 (1) 。

 (4)  当进程不再使用一个信号量控制的资源时，信号量值加1。如果此时有进程正在睡眠等待此信号量，则唤醒此进程。

维护信号量状态的是Linux内核操作系统而不是用户进程。我们可以从头文件/usr/src/linux/include/linux/sem.h 中看到内核用来维护信号量状态的各个结构的定义。信号量是一个数据集合，用户可以单独使用这一集合的每个元素。要调用的第一个函数是semget，用以获得一个信号量ID。

#include <sys/types.h>

#include <sys/ipc.h>

#include <sys/sem.h>

int semget(key_t key, int nsems, int flag);

key是前面讲过的IPC结构的关键字，它将来决定是创建新的信号量集合，还是引用一个现有的信号量集合。nsems是该集合中的信号量数。如果是创建新集合 (一般在服务器中) ，则必须指定nsems；如果是引用一个现有的信号量集合 (一般在客户机中) 则将nsems指定为0。

semctl函数用来对信号量进行操作。

int semctl(int semid, int semnum, int cmd, union semun arg);

不同的操作是通过cmd参数来实现的，在头文件sem.h中定义了7种不同的操作，实际编程时可以参照使用。

semop函数自动执行信号量集合上的操作数组。

int semop(int semid, struct sembuf semoparray[], size_t nops);

semoparray是一个指针，它指向一个信号量操作数组。nops规定该数组中操作的数量。

下面，我们看一个具体的例子，它创建一个特定的IPC结构的关键字和一个信号量，建立此信号量的索引，修改索引指向的信号量的值，最后我们清除信号量。在下面的代码中，函数ftok生成我们上文所说的唯一的IPC关键字。

 1#include <stdio.h>
 2#include <sys/types.h>
 3#include <sys/sem.h>
 4#include <sys/ipc.h>
 5void main() {
 6    key_t unique_key; /* 定义一个IPC关键字*/
 7    int id;
 8    struct sembuf lock_it;
 9    union semun options;
10    int i;
11
12    unique_key = ftok(".", 'a'); /* 生成关键字，字符'a'是一个随机种子*/
13    /* 创建一个新的信号量集合*/
14    id = semget(unique_key, 1, IPC_CREAT | IPC_EXCL | 0666);
15    printf("semaphore id=%d\n", id);
16    options.val = 1; /*设置变量值*/
17    semctl(id, 0, SETVAL, options); /*设置索引0的信号量*/
18
19    /*打印出信号量的值*/
20    i = semctl(id, 0, GETVAL, 0);
21    printf("value of semaphore at index 0 is %d\n", i);
22
23    /*下面重新设置信号量*/
24    lock_it.sem_num = 0; /*设置哪个信号量*/
25    lock_it.sem_op = -1; /*定义操作*/
26    lock_it.sem_flg = IPC_NOWAIT; /*操作方式*/
27    if (semop(id, &lock_it, 1) == -1) {
28        printf("can not lock semaphore.\n");
29        exit(1);
30    }
31
32    i = semctl(id, 0, GETVAL, 0);
33    printf("value of semaphore at index 0 is %d\n", i);
34
35    /*清除信号量*/
36    semctl(id, 0, IPC_RMID, 0);
37}

 

2.3.5  socket 

 socket  (socket) 编程是实现Linux系统和其他大多数操作系统中进程间通信的主要方式之一。我们熟知的WWW服务、FTP服务、TELNET服务等都是基于 socket 编程来实现的。除了在异地的计算机进程间以外， socket 同样适用于本地同一台计算机内部的进程间通信。关于 socket 的经典教材同样是 Richard Stevens编著的《Unix网络编程: 联网的API和 socket 》，清华大学出版社出版了该书的影印版。它同样是Linux程序员的必备书籍之一。

关于这一部分的内容，可以参照本文作者的另一篇文章《设计自己的网络蚂蚁》，那里由常用的几个 socket 函数的介绍和示例程序。这一部分或许是Linux进程间通信编程中最须关注和最吸引人的一部分，毕竟，Internet 正在我们身边以不可思议的速度发展着，如果一个程序员在设计编写他下一个程序的时候，根本没有考虑到网络，考虑到Internet，那么，可以说，他的设计很难成功。

 

3 Linux的进程和Win32的进程/线程比较

熟悉WIN32编程的人一定知道，WIN32的进程管理方式与Linux上有着很大区别，在UNIX里，只有进程的概念，但在WIN32里却还有一个"线程"的概念，那么Linux和WIN32在这里究竟有着什么区别呢？

WIN32里的进程/线程是继承自OS/2的。在WIN32里，"进程"是指一个程序，而"线程"是一个"进程"里的一个执行"线索"。从核心上讲，WIN32的多进程与Linux并无多大的区别，在WIN32里的线程才相当于Linux的进程，是一个实际正在执行的代码。但是，WIN32里同一个进程里各个线程之间是共享数据段的。这才是与Linux的进程最大的不同。

下面这段程序显示了WIN32下一个进程如何启动一个线程。

 1 int g;
 2 DWORD WINAPI ChildProcess( LPVOID lpParameter ){
 3     int i;
 4     for ( i = 1; i <1000; i ++) {
 5         g ++;
 6         printf( "This is Child Thread: %d\n", g );
 7     }
 8     ExitThread( 0 );
 9 };
10 
11 void main()
12 {
13     int threadID;
14     int i;
15     g = 0;
16     CreateThread( NULL, 0, ChildProcess, NULL, 0, &threadID );
17     for ( i = 1; i <1000; i ++) {
18         g ++;
19         printf( "This is Parent Thread: %d\n", g );
20     }
21 }

在WIN32下，使用CreateThread函数创建线程，与Linux下创建进程不同，WIN32线程不是从创建处开始运行的，而是由 CreateThread指定一个函数，线程就从那个函数处开始运行。此程序同前面的UNIX程序一样，由两个线程各打印1000条信息。 threadID是子线程的线程号，另外，全局变量g是子线程与父线程共享的，这就是与Linux最大的不同之处。大家可以看出，WIN32的进程/线程要比Linux复杂，在Linux要实现类似WIN32的线程并不难，只要fork以后，让子进程调用ThreadProc函数，并且为全局变量开设共享数据区就行了，但在WIN32下就无法实现类似fork的功能了。所以现在WIN32下的C语言编译器所提供的库函数虽然已经能兼容大多数 Linux/UNIX的库函数，但却仍无法实现fork。

 


对于多任务系统，共享数据区是必要的，但也是一个容易引起混乱的问题，在WIN32下，一个程序员很容易忘记线程之间的数据是共享的这一情况，一个线程修改过一个变量后，另一个线程却又修改了它，结果引起程序出问题。但在Linux下，由于变量本来并不共享，而由程序员来显式地指定要共享的数据，使程序变得更清晰与安全。

至于WIN32的"进程"概念，其含义则是"应用程序"，也就是相当于UNIX下的exec了。

Linux也有自己的多线程函数pthread，它既不同于Linux的进程，也不同于WIN32下的进程，关于pthread的介绍和如何在Linux环境下编写多线程程序我们将在另一篇文章《Linux下的多线程编程》中讲述。

 

4 鸣谢

本文作者:winnxm

本文部分内容参照《Linux下的多进程编程》，原作者俞磊


### golang fork

在 Unix 中，创建一个进程，通过系统调用 fork 实现 (及其一些变种，如 vfork、clone) 。在 Go 语言中，Linux 下创建进程使用的系统调用是 clone。

很多时候，系统调用 fork、execve、wait 和 exit 会在一起出现。此处先简要介绍这 4 个系统调用及其典型用法。

fork: 允许一进程 (父进程) 创建一新进程 (子进程) 。具体做法是，新的子进程几近于对父进程的翻版: 子进程获得父进程的栈、数据段、堆和执行文本段的拷贝。可将此视为把父进程一分为二。
exit(status): 终止一进程，将进程占用的所有资源 (内存、文件描述符等) 归还内核，交其进行再次分配。参数 status 为一整型变量，表示进程的退出状态。父进程可使用系统调用 wait() 来获取该状态。
wait(&status) 目的有二: 其一，如果子进程尚未调用 exit() 终止，那么 wait 会挂起父进程直至子进程终止；其二，子进程的终止状态通过 wait 的 status 参数返回。
execve(pathname, argv, envp) 加载一个新程序 (路径名为 pathname，参数列表为 argv，环境变量列表为 envp) 到当前进程的内存。这将丢弃现存的程序文本段，并为新程序重新创建栈、数据段以及堆。通常将这一动作称为执行一个新程序。
在 Go 语言中，没有直接提供 fork 系统调用的封装，而是将 fork 和 execve 合二为一，提供了 syscall.ForkExec。如果想只调用 fork，得自己通过 syscall.Syscall(syscall.SYS_FORK, 0, 0, 0) 实现。

---

https://www.cnblogs.com/qingergege/p/6601807.html  
https://www.cnblogs.com/hicjiajia/archive/2011/01/20/1940154.html  
http://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter10/10.1.html  
