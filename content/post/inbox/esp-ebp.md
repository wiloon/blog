---
title: "esp,ebp,栈指针,帧指针"
author: "-"
date: ""
url: "template"
categories:
  - inbox
tags:
  - inbox
---
## "esp,ebp,栈指针,帧指针"

 (1) ESP: 栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。
 (2) EBP: 基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。


栈帧每一个都对应一个过程，而且每一个帧指针+4的位置都存储着函数的返回地址，每一个帧指针指向的存储器位置当中都备份着调用者的帧指针。各位需要知道的是，每一个栈帧都建立在调用者的下方 (也就是地址递减的方向) ，当被调用者执行完毕时，这一段栈帧会被释放。还有一点很重要的是，%ebp和%esp的值指示着栈帧的两端，而栈指针会在运行时移动，所以大部分时候，在访问存储器的时候会基于帧指针访问，因为在一直移动的栈指针无法根据偏移量准确的定位一个存储器位置。

还有一点比较重要的内容，就是栈帧当中内存的分配和释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。这个理解起来很简单，因为在栈指针向下移动以后 (也就是变小了) ，帧指针和栈指针中间的区域会变长，这就是给栈帧分配了更多的内存。相反，如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。需要注意的是，上面的一切内容，都基于一个前提，那就是帧指针在过程调用当中是不会移动的。

---

函数调用的故事

1. 调用者的各种参数入栈
2. 调用者的返回地址入栈，这个是用  前指令地址++  作返回地址的
3. 调用者的帧指针入栈保护 (本次调用的基址指针就指向这里) 
4. 调用者的寄存器入栈保护
5. 被调用的函数的局部变量的分配

---

https://blog.csdn.net/u011822516/article/details/20001765  
https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html  
https://zhuanlan.zhihu.com/p/37537046  
