---
title: 缓存
author: "-"
type: post
date: 2014-05-29T01:07:30+00:00
url: /?p=6682

---

https://xie.infoq.cn/article/0134f29b0c0895df548dd929b?utm_source=rss&utm_medium=article


缓存的存在，是为了调和差异。

差异有多种，比如处理器和存储之间的速度差异、用户对产品的使用体验和服务处理效率的差异等等。

CPU 缓存[2]。为了调和 CPU 和内存之间巨大的速度差异，设置了 L1/L2/L3 三级缓存，离 CPU 越近，速度越快。   

Ehcache[3]。是最流行了 Java 缓存框架之一。因为其开源属性，在 spring/Hibernate 等框架上被广泛使用。支持磁盘持久化和堆外内存。缓存功能齐全。

Guava cache。灵感来源于 ConcurrentHashMap，但具有更丰富的元素失效策略，功能没有 ehcache 齐全，如只支持 jvm 内存，但比较轻量简洁。

memcached。[5]  memcached 是一个高效的分布式内存 cache，搭建与操作使用都比较简单，整个缓存都是基于内存的，因此响应时间很快，但是没有持久化的能力。

Redis 以优秀的性能和丰富的数据结构，以及稳定性和数据一致性的支持，被业内越来越普遍的使用。


缓存穿透
查询的是数据库中不存在的数据，没有命中缓存而数据库查询为空，也不会更新缓存。导致每次都查库，如果不加处理，遇到恶意攻击，会导致数据库承受巨大压力，直至崩溃。

解决方案有两种：一种是遇到查询为空的，就缓存一个空值到缓存，不至于每次都进数据库。二是布隆过滤器，提前判断是否是数据库中存在的数据，若不在则拦截。

2.2 缓存击穿
从字面意思看，缓存起初时起作用的。发生的场景是某些热点 key 的缓存失效导致大量热点请求打到数据库，导致数据库压力陡增，甚至宕机。

解决方案有两种：

一种是热点 key 不过期。有的同学在这里提出了逻辑过期的方案，即物理上不设置过期时间，将期望的过期时间存在 value 中，在查询到 value 时，通过异步线程进行缓存重建。

第二种是从执行逻辑上进行限制，比如，起一个单一线程的线程池让热点 key 排队访问底层存储，以损失系统吞吐量的代价来维护系统稳定。


2.3 缓存雪崩
鉴于缓存的作用，一般在数据存入时，会设置一个失效时间，如果插入操作是和用户操作同步进行，则该问题出现的可能性不大，因为用户的操作天然就是散列均匀的。

而另一些例如缓存预热的情况，依赖离线任务，定时批量的进行数据更新或存储，过期时间问题则要特别关注。

因为离线任务会在短时间内将大批数据操作完成，如果过期时间设置的一样，会在同一时间过期失效，后果则是上游请求会在同一时间将大量失效请求打到下游数据库，从而造成底层存储压力。同样的情况还发生在缓存宕机的时候。

解决方案：

一是考虑热点数据不过期获取用上一节提到的逻辑过期。

二是让过期时间离散化，如，在固定的过期时间上额外增加一个随机数，这样会让缓存失效的时间分散在不同时间点，底层存储不至于瞬间飙升。

三是用集群主从的方式，保障缓存服务的高可用。防止全面崩溃。当然也要有相应的熔断和限流机制来应对可能的缓存宕机。


2.4 数据漂移



2.5 缓存踩踏[6]
缓存踩踏其实只是一种缓存失效场景的提法，底层原因是缓存为空或还未生效。关键是因为上游调用超时后唤起重试，引发恶性循环。

比如，当某一名人新发布了图片，而他们粉丝都会收到通知，大量的粉丝争先抢后的想去看发布了什么，但是，因为是新发布的图片，服务端还没有进行缓存，就会发生大量请求被打到底层存储，超过服务处理能力导致超时后，粉丝又会不停的刷新，造成恶性循环。

解决方案：锁 和 Promise。

发生这种踩踏的底层原因是对缓存这类公共资源拼抢，那么，就把公共资源加锁，消除并发拼抢。

但是，加锁在解决公共资源拼抢的同时，引发了另一个问题，即没有抢占到锁的线程会阻塞等待唤醒，当锁被释放时，所有线程被一同唤醒，大量线程的阻塞和唤醒是对服务器资源极大的消耗和浪费，即_惊群效应_。


promise 的工作原理

promise 的原理其实是一种_代理模式_，实际的缓存值被 promise 代替，所有的线程获取 promise 并等待 promise 返回给他们结果 , 而 promise 负责去底层存储获取数据，通过异步通知方式，最终将结果返回给各工作线程。

这样，就不会发生大量并发请求同时操作底层存储的情况。




https://segmentfault.com/a/1190000017375843


