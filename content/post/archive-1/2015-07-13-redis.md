---
title: Redis, redis basic
author: w1100n
type: post
date: 2015-07-13T09:06:18+00:00
url: /?p=8023
tags:
  - Database

---
REmote DIctionary Server(Redis) 是一个由SalvatoreSanfilippo写的key-value存储系统。

Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
  
Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。[1]
  
Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。
  
redis的官网地址，非常好记，是redis.io。（特意查了一下，域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地）
  
目前，Vmware在资助着redis项目的开发和维护。redis[2] 的作者，叫Salvatore Sanfilippo，来自意大利的西西里岛，现在居住在卡塔尼亚。目前供职于Pivotal公司。他使用的网名是antirez。

Redis 4.0 之后的版本，情况就有了一些变动，新版的 Redis 服务在执行一些命令时就会使用『主处理线程』之外的其他线程，例如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC 等非阻塞的删除操作。
Redis 在较新的版本中引入了多线程，不过是在部分命令上引入的，其中包括非阻塞的删除操作，在整体的架构设计上，主处理程序还是单线程模型的

### 线程模型
使用单线程模型能带来更好的可维护性，方便开发和调试；  
使用单线程模型也能并发的处理客户端的请求；  
Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；  

#### 6.0
I/O 多路复用的主要作用是让我们可以使用一个线程来监控多个连接是否可读或者可写，但是从网络另一头发的数据包需要先解序列化成 Redis 内部其他模块可以理解的命令，这个过程就是 Redis 6.0 引入多线程来并发处理的。

I/O 多路复用模块收到数据包之后将其丢给后面多个 I/O 线程进行解析，I/O 线程处理结束后，主线程会负责串行的执行这些命令，由于向客户端发回数据包的过程也是比较耗时的，所以执行之后的结果也会交给多个 I/O 线程发送回客户端。

### AOF
AOF 是 Redis 的一种持久化机制，它会在每次收到来自客户端的写请求时，将其记录到日志中，每次 Redis 服务器启动时都会重放 AOF 日志构建原始的数据集，保证数据的持久性。

### java sdk
- redisson
- jedis

### 查看版本等信息
    info

### version
    prod: 5.0.5
    latest: 6.2

### URLs
    https://redis.io/
    https://github.com/redis/redis

### install

#### rpm
download redis rpm from https://pkgs.org/download/redis
  
下载Redis的依赖包: libjemalloc

下载地址: https://pkgs.org/centos-6/atomic-x86_64/jemalloc-3.6.0-1.el6.art.x86_64.rpm.html

```bash
rpm -ivh jemalloc-3.6.0-1.el6.art.x86_64.rpm
rpm -ivh redis-2.8.20-3.el6.art.x86_64.rpm
```

### podman, 单机redis
```bash
podman run \
-d \
--name redis \
-p 6379:6379 \
-v /etc/localtime:/etc/localtime:ro \
redis:6.2.4

podman run -it --rm redis redis-cli -h redis.wiloon.com


podman run \
-d \
--name redis \
-p 6379:6379 \
-v /etc/localtime:/etc/localtime:ro \
-v redis-conf:/usr/local/etc/redis \
-v redis-data:/data/redis \
redis:6.2.4 redis-server /usr/local/etc/redis/redis.conf

```

```bash
redis-server --version
```

### delete key
del key1 key2

### 判断key是否存在
exists key_name

### 查看key的类型
    type key0

### 删除 key
    DEL key [key ...]

### 设置过期时间

EXPIRE key0 10

### ttl: 返回给定 key 的剩余生存时间(TTL, time to live)
    TTL key
### 查看各个库的key数量
    info keyspace

以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。

可用版本: >= 1.0.0

时间复杂度: O(1)

返回值: 
  
当 key 不存在时，返回 -2 。
  
当 key 存在但没有设置剩余生存时间时，返回 -1 。
  
否则，以秒为单位，返回 key 的剩余生存时间。

O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).

```bash
redis-cli -h 127.0.0.1 -p 6379

#cluster
redis-cli -c -h 127.0.0.1 -p 6379

# 不进入交互模式, 直接执行命令
redis-cli -h 127.0.0.1 -p 6379 hget key0 field0

client list
client kill ip:port

#查特定pattern的key 数量
redis-cli keys *xxx* |grep "" -c

批量删除Redis下特定pattern的keys
可以使用linux的xargs来做到如: 
*/redis-cli keys "prefix*" | xargs */redis-cli del 

如果是访问特定的数据库，则可以: 
*/redis-cli -n 0 keys "prefix*" | xargs */redis-cli -n 0 del

set set key0 value0 
get del key 
#delete key 

redis-server.exe 
redis.windows.conf 
redis-cli.exe

#当前数据库中key的数量 
DBSIZE

#清空当前数据库 
flushdb 

#info
# http://redisdoc.com/server/info.html
```

### cluster

```bash
创建集群主节点

redis-cli --cluster create 192.168.163.132:6379 192.168.163.132:6380 192.168.163.132:6381
创建集群主从节点

/redis-cli --cluster create 192.168.163.132:6379 192.168.163.132:6380 192.168.163.132:6381 192.168.163.132:6382 192.168.163.132:6383 192.168.163.132:6384 --cluster-replicas 1

#  检查集群
redis-cli --cluster check 192.168.163.132:6384 --cluster-search-multiple-owners

# 集群信息查看
redis-cli --cluster info 192.168.163.132:6384
# 修复集群
redis-cli --cluster fix 192.168.163.132:6384 --cluster-search-multiple-owners
# 添加集群主节点

redis-cli --cluster add-node 192.168.163.132:6382 192.168.163.132:6379 
说明: 为一个指定集群添加节点，需要先连到该集群的任意一个节点IP（192.168.163.132:6379），再把新节点加入。该2个参数的顺序有要求: 新加入的节点放前
# 添加集群从节点

redis-cli --cluster add-node 192.168.163.132:6382 192.168.163.132:6379 --cluster-slave --cluster-master-id 117457eab5071954faab5e81c3170600d5192270
说明: 把6382节点加入到6379节点的集群中，并且当做node_id为 117457eab5071954faab5e81c3170600d5192270 的从节点。如果不指定 --cluster-master-id 会随机分配到任意一个主节点。

删除节点

redis-cli --cluster del-node 192.168.163.132:6384 f6a6957421b00009106cb36be3c7ba41f3b603ff
说明: 指定IP、端口和node_id 来删除一个节点，从节点可以直接删除，主节点不能直接删除，删除之后，该节点会被shutdown。

```

### Keyspace Notifications, 键空间通知
在Redis2.8.0版本的时候，推出 Keyspace Notifications future。   Keyspace Notifications 此特性允许客户端可以以 订阅/发布（Sub/Pub）模式，接收那些对数据库中的键和值有影响的操作事件。这些操作事件具体来说，就是 hash , del, expire , set , lpop 等。
那么你可能会问，redis keyspace 到底有啥用处？   简单说，对于我个人主要关注keyspace几个扩展场景:

1.  类似审计或者监控的场景. 

2.  通过expire来实现不可靠的定时器. 

3.  借助expire来实现不可靠的注册发现.  

为什么说是不可靠的实现?

首先Redis Pub/Sub 是一种并不可靠地消息机制，他不会做信息的存储，只是在线转发，那么肯定也没有ack确认机制，另外只有订阅段监听时才会转发!!!    所以Keyspace Notification 也不是可靠地通知系统，如果你的系统需要很好的可靠性，那么Keyspace Notification可能并不是一种很好的选择。



默认情况下，Redis 并不会开启Keyspace Notification， 我们可以通过修改redis.conf的notify-keyspace-events 或者使用CONFIG SET命令来开启该功能，设置参数，来开启全部或者部分通知

### slot
slot 是什么
我们都知道在集群模式下key是需要进行路由的，那就需要有路由策略，Redis Cluster并没有使用一致性hash的方案,而是使用分配slot的方式进行key路由。

如何分配slot
Redis Cluster为整个集群定义了一共16384个slot，并通过crc16的hash函数来对key进行取模，将结果路由到预先分配过slot的相应节点上。

1.将节点加入Redis Cluster中
2.为集群中的节点分配slot(分配完成后，每个即诶单不仅直到自己的slot列表，还需要知道别的节点的slot列表)
3.分配完成后，key会根据crc16计算出得结果和16384取模进行slot定位，从而定位到具体节点。
举个例子
节点A保存了0-5500的slot
节点B保存了5501-11000的slot
节点C保存了11001-16383的slot
当客户端要执行 SET test 123 实际上会执行crc16(123)
具体流程如下：
客户端调用SET test 123
任意节点接受到指令，将执行crc16(test)=63534
63534%16384=14382
14382术语节点C因此将key test路由到C节点。
因为指令是发到任意节点的，如果这个节点不是C节点，则会触发MOVED命令，将命令发到相应node(各个节点保存了其他节点的slot列表)


重新分配slot
所有分片的算法都会面对一个问题，就是当节点增加或减少时怎么处理,Redis Cluster也不例外
当有节点D加入进来原本的A,B,C节点需要拿出一部分slot给到D，这样的操作就叫做slot重新分配。

redis-trib
redis Cluster 是使用redis-trib来自动实现的slot重新分配

---


http://blog.csdn.net/rockstar541/article/details/30245493
  
https://www.zhihu.com/question/20698365
  
https://www.cnblogs.com/zhoujinyi/p/11606935.html
  
https://blog.51cto.com/zengestudy/1853801
https://draveness.me/whys-the-design-redis-single-thread/  
http://xiaorui.cc/archives/4123  
