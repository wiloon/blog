---
title: oracle 临时表
author: "-"
type: post
date: 2013-01-04T03:38:20+00:00
url: /?p=4968
categories:
  - DataBase

---
###  http://blog.csdn.net/wyzxg/article/details/1882347
  
     
  
  
    前段时间,新公司的面试官问了一个问题,临时表的作用,以前我们用缓存中间数据时候,都是自己建一个临时表。其实oracle本身在这方面就已经考虑很全了,除非有些高级应用,我再考虑自己创建临时表。由于本人对临时表的了解不是很多,于是回来搜集下这方面的资料,弥补下这块的不足。
  
  
     
  
  
        目前所有使用Oracle作为数据库支撑平台的应用,大部分数据量比较庞大的系统,即表的数据量一般情况下都是在百万级以上的数据量。
  
  
     
  
  
     
  
  
     我对临时表的理解: 在Oracle中创建一张表,这个表不用于其他的什么功能,主要用于自己的软件系统一些特有功能才用的,而当你用完之后表中的数据就没用了。Oracle的临时表创建之后基本不占用表空间,如果你没有指定临时表（包括临时表的索引) 存放的表空的时候,你插入到临时表的数据是存放在ORACLE系统的临时表空间中（TEMP) 。
  
  
     
  
  
    2、临时表的创建
  
  
    创建Oracle临时表,可以有两种类型的临时表: 
  
  
    会话级的临时表
  
  
    事务级的临时表。
  
  
    1)  会话级的临时表因为这这个临时表中的数据和你的当前会话有关系,当你当前SESSION不退出的情况下,临时表中的数据就还存在,而当你退出当前SESSION的时候,临时表中的数据就全部没有了,当然这个时候你如果以另外一个SESSION登陆的时候是看不到另外一个SESSION中插入到临时表中的数据的。即两个不同的SESSION所插入的数据是互不相干的。当某一个SESSION退出之后临时表中的数据就被截断（truncate table,即数据清空) 了。会话级的临时表创建方法: 
  
  
    [sql]
  
  
    Create Global Temporary Table Table_Name
  
  
    (Col1 Type1,Col2 Type2...) On Commit Preserve Rows；
  
  
    -举例: 
  
  
    create global temporary table Student
  
  
    (Stu_id Number(5),
  
  
    Class_id  Number(5),
  
  
    Stu_Name Varchar2(8),
  
  
    Stu_Memo varchar2(200)) on Commit Preserve Rows;
  
  
    [/sql]
  
  
    事务级临时表是指该临时表与事务相关,当进行事务提交或者事务回滚的时候,临时表中的数据将自行被截断,其他的内容和会话级的临时表的一致（包括退出SESSION的时候,事务级的临时表也会被自动截断) 。事务级临时表的创建方法: 
  
  
    3)   两中类型临时表的区别
  
  
    会话级临时表采用on commit preserve rows；而事务级则采用on commit delete rows；用法上,会话级别只有当会话结束临时表中的数据才会被截断,而且事务级临时表则不管是commit、rollback或者是会话结束,临时表中的数据都将被截断
  
  
     
  
  
    [sql]
  
  
    Create Global Temporary Table Table_Name
  
  
    (Col1 Type1,Col2 Type2...) On Commit Delete Rows；
  
  
    -举例: 
  
  
    create global temporary table Classes
  
  
    (Class_id Number(5),
  
  
    Class_Name Varchar2(8),
  
  
    Class_Memo varchar2(200)) on Commit delete Rows ;
  
  
    [/sql]
  
  
    4) 什么时候使用临时表 
  
  
    1) 、当某一个SQL语句关联的表在2张及以上,并且和一些小表关联。可以采用将大表进行分拆并且得到比较小的结果集合存放在临时表中
  
  
    2) 、程序执行过程中可能需要存放一些临时的数据,这些数据在整个程序的会话过程中都需要用的等等。
  
  
     
  
  
     
  
  
    3．例子: 略
  
  
    4．临时表的不足之处
  
  
     
  
  
        1) 不支持lob对象,这也许是设计者基于运行效率的考虑,但实际应用中确实需要此功能时就无法使用临时表了。
  
  
    2) 不支持主外键关系
  
  
     
  
  
    所以,由于以上原因,我们可以自己创建临时表,以弥补oracle临时表的不足之处
  
  
     
  
  
    上面的都是本人经过测试的,但下面是在网上搜索到的方法,本人具体没有测试过,不过觉得可行性很强,有时间测试下
  
  
     
  
  
       创建方法: 
  
  
          1、以常规表的形式创建临时数据表的表结构,但要在每一个表的主键中加入一个 SessionID <NUMBER> 列以区分不同的会话。（可以有lob列和主外键) 
  
  
    2、写一个用户注销触发器,在用户结束会话的时候删除本次会话所插入的所有记录(SessionID等于本次会话ID的记录)。
  
  
    3、程序写入数据时,要顺便将当前的会话ID(SessionID)写入表中。
  
  
    4、程序读取数据时,只读取与当前会话ID相同的记录即可。
  
  
       功能增强的扩展设计: 
 　　1、可以在数据表上建立一个视图,视图对记录的筛选条件就是当前会话的SessionID。
 　　2、数据表中的SessionID列可以通过Trigger实现,以实现对应用层的透明性。
 　　3、高级用户可以访问全局数据,以实现更加复杂的功能。
  
  
    　　扩展临时表的优点: 
 　　1、实现了与Oracle的基于会话的临时表相同的功能。
 　　2、支持SDO_GEOMETRY等lob数据类型。
 　　3、支持表间的主外键连接,且主外键连接也是基于会话的。
 　　4、高级用户可以访问全局数据,以实现更加复杂的功能
  
