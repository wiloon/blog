---
title: 文件权限
author: "-"
date: 2015-02-06T03:25:31+00:00
url: /?p=7325
categories:
  - Uncategorized
tags:
  - linux

---
## 文件权限

## Linux 文件权限

### 模式 数字

    rwx 7
    rw- 6
    r-x 5
    r-- 4
    -wx 3
    -w- 2
    -x- 1
    --- 0

<http://zhangfeikr.blog.51cto.com/1999170/396541>

一个用户、一个组
  
我们来看一看 Linux 权限和所有权模型。我们已经看到每个文件属于一个用户和一个组。这正是 Linux 中权限模型的核心。您可以在 ls -l 清单中查看用户和组:
  
$ ls -l /bin/bash
  
-rwxr-xr-x 1 root wheel 430540 Dec 23 18:27 /bin/bash
  
在这个特殊的示例中，/bin/bash 可执行文件属于 root 用户，并且在 wheel 组中。Linux 权限模型通过允许给每个文件系统对象设置三种独立的权限级别来工作 — 它们为文件的所有者、文件的组以及所有其他用户。
  
理解"ls -l"
  
我们来看一看我们的 ls -l 输出，检查一下这个清单的第一栏:
  
$ ls -l /bin/bash
  
-rwxr-xr-x 1 root wheel 430540 Dec 23 18:27 /bin/bash
  
第一个字段 -rwxr-xr-x 包含该特殊文件的权限的符号表示。该字段中的首字符 (-) 指定该文件的类型，本例中它是一个常规文件。其它可能的首字符还有:
  
"d"目录
  
"l"符号链接
  
"c"字符专门设备文件
  
"b"块专门设备文件
  
"p"先进先出
  
"s" socket
  
三个三元组
  
$ ls -l /bin/bash
  
-rwxr-xr-x 1 root wheel 430540 Dec 23 18:27 /bin/bash
  
该字段的其余部分由三个三元组字符组成。第一个三元字符组代表文件所有者的权限，第二个代表文件的组的权限，第三个代表所有其他用户的权限:
  
"rwx"
  
"r-x"
  
"r-x"
  
上面，r 表示允许读 (查看文件中的数据) ，w 表示允许写 (修改文件以及删除) ，x 表示允许"执行" (运行程序) 。将所有这些信息放在一起，我们可以发现每个人都能够读该文件的内容和执行该文件，但是只允许文件所有者 (root 用户) 可以以任何方式修改该文件。因此，虽然一般用户可以复制该文件，但是只允许 root 用户更新或删除它。
  
我是谁？
  
在我们看怎样改变文件的用户所有权和组所有权之前，我们首先来看一看怎样
  
得知您当前的用户标识和组成员资格。除非最近您使用过 su 命令，否则您当
  
前的用户标识是您用来登录系统的用户标识。但是，如果您经常使用 su，您
  
可能不记得您当前有效的用户标识。要查看用户标识，输入 whoami:
  
# whoami
  
root
  
# su drobbins
  
$ whoami
  
drobbins
  
我在哪一组？
  
要看看您属于哪一组，使用 group 命令:
  
$ groups
  
drobbins wheel audio
  
在上面的示例中，我是 drobbins、wheel 和 audio 组的成员。如果您想看看其他用户在什么组，指定他们的用户名作为参数:
  
$ groups root daemon
  
root : root bin daemon sys adm disk wheel floppy dialout tape video
  
daemon : daemon bin adm
  
改变用户和组所有权
  
为了改变文件或其它文件系统对象的所有者或组，分别使用 chown 或 chgrp。这两个命令都要一个用户名或组名作参数，后面跟上一个或多个文件名。
  
# chown root /etc/passwd
  
# chgrp wheel /etc/passwd
  
您还可以用 chown 命令的另一种形式同时设置所有者和组:
  
# chown root.wheel /etc/passwd
  
除非您是超级用户，否则您不可以使用 chown，然而任何人都可以使用 chgrp 来将文件的组所有权改为他们所属的组。
  
递归的所有权改变
  
chown 和 chgrp 都有一个 -R 选项，该选项可以用来告诉它们递归地将所属权
  
和组改变应用到整个目录树中。例如:
  
# chown -R drobbins /home/drobbins
  
介绍 chmod
  
chown 和 chgrp 可以用来改变文件系统对象的所有者和组，而另一个程序 —
  
叫做 chmod — 用来改变我们可以在 ls -l 清单中看到的 rwx 权限。chmod
  
带有两个或多个参数: "mode"，描述怎样改变权限，后面跟将会受到影响的
  
文件或文件列表:
  
$ chmod +x scriptfile.sh
  
在上面的示例中，我们的"mode"是 +x。您可能会猜到，+x 模式告诉 chmod，使该特殊文件
  
对于用户、组以及其它任何人都是可执行的。
  
如果我们想要除去一个文件的所有执行权限，我们应该这样做:
  
$ chmod -x scriptfile.sh
  
用户/组/其他粒度
  
到此，我们的 chmod 示例已经影响到了所有三个三元组 — 用户、组和所有其他用户。通常，
  
一次只修改一个或两个三元组很方便。要这样做，只需要在 + 或 - 符号之前，给您想要修改的
  
特定的三元组指定符号字符。对于"用户"三元组使用 u，对于"组"三元组使用 g，对于"其
  
他/每个人"使用 o:
  
$ chmod go-w scriptfile.sh
  
我们刚除去了组和所有其他用户的写权限，而保留"所有者"权限不动。
  
重新设置权限
  
除了交替打开和关闭权限位以外，我们还可以一起重新设置它们。通过使用 =
  
操作符，我们可以告诉 chmod 我们要指定权限和取消别的权限:
  
$ chmod =rx scriptfile.sh
  
上面，我们只设置了所有的"read"和"execute"位，没有设置所有的
  
"write"位。如果您仅仅想重新设置特定的三元组，您可以像下面这样，
  
在 = 之前指定该三元组的符号名:
  
$ chmod u=rx scriptfile.sh

数字模式

直到现在为止，我们使用了叫做"符号"的模式来用 chmod 指定权限的改变。然而，指定
  
权限还有

一种普遍使用的方法 — 使用 4 位八进制数。使用叫做数字权限语法的语法，每一位代表一
  
个权限

三元组。例如，在 1777 中，777 设置本章我们所讨论的"owner"、"group"和"other"

标志。1 用来设置专门的权限位，我们将在本章的结束部分讲到。这个图表说明了怎样解释第二到

四位 (777) :

数字权限语法
  
当您需要给一个文件指定所有权限时，数字权限语法特别有用，比如在下面的示例中:
  
$ chmod 0755 scriptfile.sh

$ ls -l scriptfile.sh

-rwxr-xr-x 1 drobbins drobbins 0 Jan 9 17:44 scriptfile.sh

在该示例中，我们使用了 0755 模式，它展开为一个完整的权限设置"-rwxr-xr-x"。

Umask

当进程创建了新文件时，它指定新文件应该具有的权限。通常，所请求的模式
  
是 0666 (每个人可读和可写) ，它比我们希望的具有更多的权限。幸运的是
  
，不管什么时候创建了新文件，Linux 将参考叫做"umask"的东西。系统用
  
umask 值来将初始指定的权限降低为更合理、更安全的权限。您可以通过在
  
命令行中输入 umask 来查看您当前的 umask 设置:

$ umask

0022

Linux 系统上，umask 的缺省值一般为 0022，它允许其他人读您的新文件 (如果他们可以
  
得到它们) ，但是不能进行修改。
  
为了在缺省的情况下使新文件更安全，您可以改变 umask 设置:
  
$ umask 0077
  
umask 将确保组和其他用户对于新创建的文件绝对没有任何权限。那么，umask 怎样工作呢？
  
与文件的"常规"权限不同，umask 指定应该关闭哪一个权限。我们来参阅一下我们的"模式
  
到数字"映射表，从而使我们可以理解 0077 的 umask 的意思是什么:
  
模式 数字
  
rwx 7
  
rw- 6
  
r-x 5
  
r- 4
  
-wx 3
  
-w- 2
  
-x 1
  
- 0
  
使用该表，0077 的最后三位扩展为 -rwxrwx。现在，请记住 umask 告诉系统禁用哪个权限。
  
根据推断，我们可以看到将关闭所有"组"和"其他"权限，而"用户"权限将保留不动。
  
介绍 suid 和 sgid

当您最初登录时，将启动一个新的 shell 进程。您已经知道，但是您可能还不知道这个新的 shell

进程 (通常是 bash) 使用您的用户标识运行。照这样，bash 程序可以访问所有属于您的文件和

目录。事实上，作为用户，我们完全依靠其它程序来代表我们执行操作。因为您启动的程序继承了

您的用户标识，因此它们不能访问任何不允许您访问的文件系统对象。

例如，一般用户不能直接修改 passwd 文件，因为"write"标志已经对除"root 用户"以外的每个用户关闭:
  
$ ls -l /etc/passwd

-rw-r-r- 1 root wheel 1355 Nov 1 21:16 /etc/passwd

但是，一般用户确实需要在他们需要改变其密码的任何时候，能够修改 /etc/passwd (至少间
  
接地) 。但是，如果用户不能修改该文件，究竟怎样完成这个工作呢？

Suid

幸好，Linux 权限模型有两个专门的位，叫做"suid"和"sgid"。当设置了一个可执行程序
  
的"suid"这一位时，它将代表可执行文件的所有者运行，而不是代表启动程序的人运行。
  
现在，回到 /etc/passwd 问题。如果看一看 passwd 可执行文件，我们可以
  
看到它属于 root 用户:

$ ls -l /usr/bin/passwd

-rwsr-xr-x 1 root wheel 17588 Sep 24 00:53 /usr/bin/passwd

您还将注意到，这里有一个 s 取替了用户权限三元组中的一个 x。这表明，对于这个特殊程序，
  
设置了 suid 和可执行位。由于这个原因，当 passwd 运行时，它将代表 root 用户执行 (
  
具有完全超级用户访问权) ，而不是代表运行它的用户运行。又因为 passwd 以 root 用户访
  
问权运行，所以能够修改 /etc/passwd 文件，而没有什么问题。

suid/sgid 告诫说明

我们看到了 suid 怎样工作，sgid 以同样的方式工作。它允许程序继承程序的组所有权，而不
  
是当前用户的程序所有权。
  
这里有一些关于 suid 和 sgid 的其它的但是很重要的信息。首先，suid 和 sgid 占据与
  
ls -l 清单中 x 位相同的空间。如果还设置了 x 位，则相应的位表示为 s (小写) 。但是，
  
如果没有设置 x 位，它将表示为 S (大写) 。
  
另一个很重要的提示: 在许多环境中，suid 和 suid 很管用，但是不恰当地使用这些位可能使
  
系统的安全遭到破坏。最好尽可能地少用"suid"程序。passwd 命令是为数不多的必须使用
  
"suid"的命令之一。

改变 suid 和 sgid

设置和除去 suid 与 sgid 位相当简单。这里，我们设置 suid 位:

# chmod u+s /usr/bin/myapp

此处，我们从一个目录除去 sgid 位。我们将看到 sgid 位怎样影响下面几屏中
  
的目录:
  
# chmod g-s /home/drobbins

权限和目
  
到此为止，我们从常规文件的角度来看权限。当从目录的角度看权限时，情况有一点不同。目录使
  
用同样的权限标志，但是它们被解释为表示略微不同的含义。
  
对于一个目录，如果设置了"read"标志，您可以列出目录的内容；"write"表示您可以在目
  
录中创建文件，"execute"表示您可以进入该目录并访问内部的任何子目录。没有"execute"
  
标志，目录内的文件系统对象是不可访问的。没有"read"标志，目录内的文件系统对象是不可
  
查看的，但是只要有人知道磁盘上对象的完整路径，就仍然可以访问目录内的对象。
  
目录和 sgid
  
如果启用了目录的"sgid"标志，在目录内创建的任何文件系统对象将继承目录
  
的组。当您需要创建一个属于同一组的一组人使用的目录树时，这种特殊的功能
  
很管用。只需要这样做:

# mkdir /home/groupspace

# chgrp mygroup /home/groupspace

# chmod g+s /home/groupspace

现在，mygroup 组中的所有用户都可以在 /home/groupspace 内创建文件或目录，同样，他

们也将自动地分配到 mygroup 的组所有权。根据用户的 umask 设置，新文件系统对象对于

mygroup 组的其他成员来说，可以或不可以是可读、可写或可执行的。

目录和删除

缺省情况下，Linux 目录以一种不是在所有情况下都很理想的方式表现。一般来说，只要对一个

目录有写访问权，任何人都可以重命名或删除该目录中的文件。对于个别用户使用的目录，这种行

为是很合理的。

但是，对于很多用户使用的目录来说，尤其是 /tmp 和 /var/tmp，这种行为可能会产生麻烦。

因为任何人都可以写这些目录，任何人都可以删除或重命名任何其他人的文件 — 即使是不属于

他们的！显然，当任何其他用户在任何时候都可以输入"rm -rf /tmp/*"并损坏每个人的文

件时，很难把 /tmp 用于任何有意义的文件。

所幸，Linux 有叫做"粘滞位" (sticky bit) 的东西。当给 /tmp 设置了粘滞位 (用

chmod +t) ，唯一能够删除或重命名 /tmp 中文件的是该目录的所有者 (通常是 root 用户)

、文件的所有者或 root 用户。事实上，所有 Linux 分发包都缺省地启用了 /tmp 的粘滞位，

而您还可以发现粘滞位在其它情况下也很管用。

难以理解的第一位

总结本章，我们最后来看一看数字模式的难以理解的第一位数。您可以看到，这个第一位数

用来设置 sticky、suid 和 sgid 位:

suid sgid sticky 模式数字
  
on on on 7
  
on on off 6
  
on off on 5
  
on off off 4
  
off on on 3
  
off on off 2
  
off off on 1
  
off off off 0

这里有一个怎样用 4 位数字模式来设置一个目录的权限的示例，该目录将由一个工作组使用:

# chmod 1775 /home/groupfiles

请想一想 1755 数字模式权限设置的含义。
