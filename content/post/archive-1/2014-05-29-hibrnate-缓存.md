---
title: hibrnate 缓存
author: w1100n
type: post
date: 2014-05-29T01:07:30+00:00
url: /?p=6682
categories:
  - Uncategorized

---
http://blog.csdn.net/huayu815/article/details/6860596

缓存可以简单的看成一个 Map ，通过 key 在缓存里面找 value 。

一、缓存简介 Cache In Hibernate
  
HIBERNATE 中的 CACHE 有两级 .
  
一级是在 Session 范围内的 CACHE . 即每个 Session 有自己的一个 CACHE, 当前操作的对象都会被保留在 CACHE 中 . 但是 Session 关闭后这个 CACHE 也就没有 . 可见这级 CACHE 的生命期是很短的 . （使用 id 进行关键字存储: 缓存的 key 就是 ID ， value 是 POJO ） ( 缓存的是实体对象 )
  
另一级 CACHE 是在 SessionFactory 范围的 , 可以被来自同一个 SessionFactory 的 Session 共享 . 在 HIBERNATE 的文档中称其为 SECOND LEVEL CACHE. 显然后者的优势较明显 , 也比较复合当前的使用环境 . 它可以使用不同的缓存实现，如 EhCache 、 JBossCache 、 OsCache 等 （二级缓存是缓存实体对象的）

还有一个类型的 CACHE 就是 QueryCache . 它的作用就是缓存一个 Query 以及 Query 返回对象的 Identifier 以及对象的类型 . 有了 QueryCache 后就可以高效的使用 SECOND LEVEL CACHE.
  
hibernate 查询缓存 (hibernate 默认是关闭的 )
  
查询缓存是针对普通属性结果集的缓存
  
对实体对象的结果集只缓存 id
  
查询缓存的生命周期，当前关联的表发生修改，那么查询缓存生命周期结束
  
查询缓存的配置和使用: 
  
1. 启用查询缓存: 在 hibernate .cfg.xml 中加入: 
  
<property name="hibernate .cache.use_query_cache">true</property>
  
2. 在程序中必须手动启用查询缓存，如:  query.setCacheable(true);
  
QueryCache 用来缓存查询语句 , 及查询结果集中对象的 Identifier 与 Type. 当再次使用已缓存的 Query 时 , 就可以通过对象的 Identifier 与 Type 在 SECOND LEVEL CACHE 中查找实际的对象 .
  
对于查询缓存来说，缓存的 key 是根据 hql 生成的 sql ，再加上参数，分页等信息（可以通过日志输出看到，不过它的输出不是很可读，最好改一下它的代码）。

注: 一级缓存也叫 session 级的缓存或事务缓存。 Hibernate 二级缓存也称为进程级的缓存或 SessionFactory 级的缓存。二级缓存是全局缓存，它可以被所有的 session 共享。二级缓存的生命周期和 SessionFactory 的生命周期一致， SessionFactory 可以管理二级缓存。

二、缓存的范围
  
缓存的范围分为 3 类 :
  
1. 事务范围
  
事务范围的缓存只能被当前事务访问 , 每个事务都有各自的缓存 , 缓存内的数据通常采用相互关联的对象形式 . 缓存的生命周期依赖于事务的生命周期 , 只有当事务结束时 , 缓存的生命周期才会结束 . 事务范围的缓存使用内存作为存储介质 , 一级缓存就属于事务范围 .
  
2. 应用范围
  
应用程序的缓存可以被应用范围内的所有事务共享访问 . 缓存的生命周期依赖于应用的生命周期 , 只有当应用结束时 , 缓存的生命周期才会结束 . 应用范围的缓存可以使用内存或硬盘作为存储介质 , 二级缓存就属于应用范围 .
  
3. 集群范围
  
在集群环境中 , 缓存被一个机器或多个机器的进程共享 , 缓存中的数据被复制到集群环境中的每个进程节点 , 进程间通过远程通信来保证缓存中的数据的一致 , 缓存中的数据通常采用对象的松散数据形式 .

三、缓存的方式
  
有四种，分别为: 
  
CacheConcurrencyStrategy.NONE
  
CacheConcurrencyStrategy.READ_ONLY ，只读模式，在此模式下，如果对数据进行更新操作，会有异常；
  
CacheConcurrencyStrategy.READ_WRITE ，读写模式在更新缓存的时候会把缓存里面的数据换成一个锁，其它事务如果去取相应的缓存数据，发现被锁了，直接就去数据库查询；
  
CacheConcurrencyStrategy.NONSTRICT_READ_WRITE ，不严格的读写模式则不会的缓存数据加锁；
  
CacheConcurrencyStrategy.TRANSACTIONAL ，事务模式指缓存支持事务，当事务回滚时，缓存也能回滚，只支持 JTA 环境。

缓存的注释写法如下，加在 Entity 的 java 类上: 
  
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)