---
title: Nginx config, 配置, nginx.conf
author: wiloon
type: post
date: 2013-07-09T05:59:32+00:00
url: /?p=5626
categories:
  - Uncategorized

---
### worker_processes, nginx进程数，建议设置为等于CPU总核心数。

worker_processes 8;
  
官方英文版wiki配置说明中的描述如下，个人理解为worker角色的进程个数（nginx启动后有多少个worker处理http请求。master不处理请求，而是根据相应配置文件信息管理worker进程. master进程主要负责对外揽活（即接收客户端的请求），并将活儿合理的分配给多个worker，每个worker进程主要负责干活（处理请求））。

### worker_connections

max\_clients = worker\_processes * worker_connections;
  
官方解释如下，个人认为是每一个worker进程能并发处理（发起）的最大连接数（包含所有连接数）。

# worker\_rlimit\_nofile

#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。
  
worker\_rlimit\_nofile 65535;

proxy_bind
  
https://pengpengxp.github.io/2017-06-27-%E4%BD%BF%E7%94%A8nginx%E7%9A%84proxy_bind%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%E9%80%8F%E6%98%8E%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.html

#定义Nginx运行的用户和用户组
  
user www www;

#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]
  
error_log /var/log/nginx/error.log info;

#进程文件
  
pid /var/run/nginx.pid;

# worker_connections, 工作模式与连接数上限

events
  
{
  
#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。
  
use epoll;
  
#单个进程最大连接数（最大连接数=连接数*进程数）
  
worker_connections 65535;
  
}

#设定http服务器
  
http
  
{
  
include mime.types; #文件扩展名与文件类型映射表
  
default_type application/octet-stream; #默认文件类型
  
#charset utf-8; #默认编码
  
server\_names\_hash\_bucket\_size 128; #服务器名字的hash表大小
  
client\_header\_buffer_size 32k; #上传文件大小限制
  
large\_client\_header_buffers 4 64k; #设定请求缓
  
client\_max\_body_size 8m; #设定请求缓

autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。

sendfile on;
  
sendfile 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
  
sendfile 配置可以提高 Nginx 静态资源托管效率。sendfile 是一个系统调用，直接在内核空间完成文件发送，不需要先 read 再 write，没有上下文切换开销。
  
tcp_nopush on;
  
tcp_nodelay on;

TCP\_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP\_CORK，Nginx 里统一用 tcp_nopush 来控制它，并且只有在启用了 sendfile 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。

TCP\_NODELAY 也是一个 socket 选项，启用后会禁用 Nagle 算法，尽快发送数据，某些情况下可以节约 200ms（Nagle 算法原理是：在发出去的数据还未被确认之前，新生成的小数据先存起来，凑满一个 MSS 或者等到收到确认后再发送）。Nginx 只会针对处于 keep-alive 状态的 TCP 连接才会启用 tcp\_nodelay。

可以看到 TCP\_NOPUSH 是要等数据包累积到一定大小才发送，TCP\_NODELAY 是要尽快发送，二者相互矛盾。实际上，它们确实可以一起用，最终的效果是先填满包，再尽快发送。

keepalive_timeout 120; #长连接超时时间，单位是秒

#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。
  
fastcgi\_connect\_timeout 300;
  
fastcgi\_send\_timeout 300;
  
fastcgi\_read\_timeout 300;
  
fastcgi\_buffer\_size 64k;
  
fastcgi_buffers 4 64k;
  
fastcgi\_busy\_buffers_size 128k;
  
fastcgi\_temp\_file\_write\_size 128k;

#gzip模块设置
  
gzip on; #开启gzip压缩输出
  
gzip\_min\_length 1k; #最小压缩文件大小
  
gzip_buffers 4 16k; #压缩缓冲区
  
gzip\_http\_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
  
gzip\_comp\_level 2; #压缩等级
  
gzip_types text/plain application/x-javascript text/css application/xml;
  
#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。
  
gzip_vary on;
  
#limit\_zone crawler $binary\_remote_addr 10m; #开启限制IP连接数的时候需要使用

upstream blog.ha97.com {
  
#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。
  
server 192.168.80.121:80 weight=3;
  
server 192.168.80.122:80 weight=2;
  
server 192.168.80.123:80 weight=3;
  
}

#虚拟主机的配置
  
server
  
{
  
#监听端口
  
listen 80;
  
#域名可以有多个，用空格隔开
  
server_name www.ha97.com ha97.com;
  
index index.html index.htm index.php;
  
root /data/www/ha97;
  
location ~ ._&#46;(php|php5)?$
  
{
  
fastcgi_pass 127.0.0.1:9000;
  
fastcgi_index index.php;
  
include fastcgi.conf;
  
}
  
#图片缓存时间设置
  
location ~ ._&#46;(gif|jpg|jpeg|png|bmp|swf)$
  
{
  
expires 10d;
  
}
  
#JS和CSS缓存时间设置
  
location ~ .*&#46;(js|css)?$
  
{
  
expires 1h;
  
}
  
#日志格式设定
  
log\_format access &#8216;$remote\_addr &#8211; $remote\_user [$time\_local] "$request" &#8216;
  
&#8216;$status $body\_bytes\_sent "$http_referer" &#8216;
  
&#8216;"$http\_user\_agent" $http\_x\_forwarded_for&#8217;;
  
#定义本虚拟主机的访问日志
  
access_log /var/log/nginx/ha97access.log access;

#对 "/" 启用反向代理
  
location / {
  
proxy_pass http://127.0.0.1:88;
  
proxy_redirect off;
  
proxy\_set\_header X-Real-IP $remote_addr;
  
#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
  
proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
  
#以下是一些反向代理的配置，可选。
  
proxy\_set\_header Host $host;
  
client\_max\_body_size 10m; #允许客户端请求的最大单文件字节数
  
client\_body\_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，
  
proxy\_connect\_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)
  
proxy\_send\_timeout 90; #后端服务器数据回传时间(代理发送超时)
  
proxy\_read\_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)
  
proxy\_buffer\_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小
  
proxy\_buffers 4 32k; #proxy\_buffers缓冲区，网页平均在32k以下的设置
  
proxy\_busy\_buffers\_size 64k; #高负荷下缓冲大小（proxy\_buffers*2）
  
proxy\_temp\_file\_write\_size 64k;
  
#设定缓存文件夹大小，大于这个值，将从upstream服务器传
  
}

#设定查看Nginx状态的地址
  
location /NginxStatus {
  
stub_status on;
  
access_log on;
  
auth_basic "NginxStatus";
  
auth\_basic\_user_file conf/htpasswd;
  
#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。
  
}

#本地动静分离反向代理配置
  
#所有jsp的页面均交由tomcat或resin处理
  
location ~ .(jsp|jspx|do)?$ {
  
proxy\_set\_header Host $host;
  
proxy\_set\_header X-Real-IP $remote_addr;
  
proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
  
proxy_pass http://127.0.0.1:8080;
  
}
  
#所有静态文件由nginx直接读取不经过tomcat或resin
  
location ~ ._.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$
  
{ expires 15d; }
  
location ~ ._.(js|css)?$
  
{ expires 1h; }
  
}
  
}

更详细的模块参数请参考：http://wiki.nginx.org/Main