---
title: Android生命周期
author: wiloon
type: post
date: 2014-07-31T02:25:05+00:00
url: /?p=6865
categories:
  - Uncategorized

---
http://www.cnblogs.com/feisky/archive/2010/01/01/1637427.html

在 Android 中，多数情况下每个程序都是在各自独立的 Linux 进程中运行的。当一个程序或其某些部分被请求时，它的进程就“出生”了；当这个程序没有必要再运行下去且系统需要回收这个进程的内存用于其他程序时，这个 进程就“死亡”了。可以看出，Android 程序的生命周期是由系统控制而非程序自身直接控制。这和我们编写桌面应用程序时的思维有一些不同，一个桌面应用程序的进程也是在其他进程或用户请求时被创 建，但是往往是在程序自身收到关闭请求后执行一个特定的动作（比如从 main 函数中 return）而导致进程结束的。要想做好某种类型的程序或者某种平台下的程序的开发，最关键的就是要弄清楚这种类型的程序或整个平台下的程序的一般工作 模式并熟记在心。在 Android 中，程序的生命周期控制就是属于这个范畴——我的个人理解:)

在 Android 系统中，当某个 activity调用 startActivity(myIntent) 时，系统会在所有已经安装的程序中寻找其 intent filter 和 myIntent 最匹配的一个 activity，启动这个进程，并把这个 intent 通知给这个 activity。这就是一个程序的“生”。比如我们在 Home application 中选择 “Web browser”，系统会根据这个 intent 找到并启动 Web browser 程序，显示 Web browser 的一个 activity 供我们浏览网页（这个启动过程有点类似我们在在个人电脑上双击桌面上的一个图标，启动某个应用程序）。在 Android 中，所有的应用程序“生来就是平等的”，所以不光 Android 的核心程序甚至第三方程序也可以发出一个 intent 来启动另外一个程序中的一个 activity。Android 的这种设计非常有利于“程序部件”的重用。

一个 Android 程序的进程是何时被系统结束的呢？通俗地说，一个即将被系统关闭的程序是系统在内存不足（low memory）时，根据“重要性层次”选出来的“牺牲品”。一个进程的重要性是根据其中运行的部件和部件的状态决定的。各种进程按照重要性从高到低排列如 下：
  
1. 前台进程。这样的进程拥有一个在屏幕上显示并和用户交互的 activity 或者它的一个IntentReciver 正在运行。这样的程序重要性最高，只有在系统内存非常低，万不得已时才会被结束。
  
2. 可见进程。在屏幕上显示，但是不在前台的程序。比如一个前台进程以对话框的形式显示在该进程前面。这样的进程也很重要，它们只有在系统没有足够内存运行所有前台进程时，才会被结束。
  
3. 服务进程。这样的进程在后台持续运行，比如后台音乐播放、后台数据上传下载等。这样的进程对用户来说一般很有用，所以只有当系统没有足够内存来维持所有的前台和可见进程时，才会被结束。
  
4. 后台进程。这样的程序拥有一个用户不可见的 activity。这样的程序在系统内存不足时，按照 LRU 的顺序被结束。
  
5. 空进程。这样的进程不包含任何活动的程序部件。系统可能随时关闭这类进程。

从某种意义上讲，垃圾收集机制把程序员从“内存管理噩梦”中解放出来，而 Android 的进程生命周期管理机制把用户从“任务管理噩梦”中解放出来。我见过一些 Nokia S60 用户和 Windows Mobile 用户要么因为长期不关闭多余的应用程序而导致系统变慢，要么因为不时查看应用程序列表而影响使用体验。Android 使用 Java 作为应用程序 API，并且结合其独特的生命周期管理机制同时为开发者和使用者提供最大程度的便利。

Activity lifecycle
  
Activity有三种基本状态：

Active：处于屏幕前景（当前task的栈顶Activity处于Active状态），同一时刻只能有一个Activity处于Active状态；
  
Paused状态：处于背景画面画面状态，失去了焦点，但依然是活动状态；
  
stopped：不可见，但依然保持所有的状态和内存信息。
  
可以调用finish()结束处理Paused或者stopped状态的Activity。

各种状态之间通过下列的函数调用转换：

void onCreate(Bundle savedInstanceState)
  
void onStart()
  
void onRestart()
  
void onResume()
  
void onPause()
  
void onStop()
  
void onDestroy()

Activity的生命周期可以分为三组：

The entire lifetime of an activity happens between the first call toonCreate() through to a single final call to onDestroy().
  
The visible lifetime of an activity happens between a call toonStart() until a corresponding call to onStop().

The foreground lifetime of an activity happens between a call to onResume() until a corresponding call toonPause().

activity_lifecycle

&nbsp;

保存Activity状态

To capture that state before the activity is killed, you can implement an onSaveInstanceState() method for the activity. Android calls this method before making the activity vulnerable to being destroyed — that is, before onPause() is called. It passes the method a Bundle object where you can record the dynamic state of the activity as name-value pairs. When the activity is again started, the Bundle is passed both to onCreate() and to a method that&#8217;s called after onStart(),onRestoreInstanceState(), so that either or both of them can recreate the captured state.

Unlike onPause() and the other methods discussed earlier, onSaveInstanceState() and onRestoreInstanceState()are not lifecycle methods. They are not always called. Because onSaveInstanceState() is not always called, you should use it only to record the transient state of the activity, not to store persistent data. Use onPause() for that purpose instead.

启动另一个Activity的过程

The current activity&#8217;s onPause() method is called.
  
Next, the starting activity&#8217;s onCreate(), onStart(), and onResume() methods are called in sequence.
  
Then, if the starting activity is no longer visible on screen, its onStop() method is called.
  
service生命周期
  
A service can be used in two ways:

It can be started and allowed to run until someone stops it or it stops itself. In this mode, it&#8217;s started by callingContext.startService() and stopped by calling Context.stopService(). It can stop itself by callingService.stopSelf() or Service.stopSelfResult(). Only one stopService() call is needed to stop the service, no matter how many times startService() was called.
  
It can be operated programmatically using an interface that it defines and exports. Clients establish a connection to the Service object and use that connection to call into the service. The connection is established by callingContext.bindService(), and is closed by calling Context.unbindService(). Multiple clients can bind to the same service. If the service has not already been launched, bindService() can optionally launch it.

相关的方法：

void onCreate()
  
void onStart(Intent intent)
  
void onDestroy()

The onCreate() and onDestroy() methods are called for all services, whether they&#8217;re started byContext.startService() or Context.bindService(). However, onStart() is called only for services started bystartService().

If a service permits others to bind to it, there are additional callback methods for it to implement:

IBinder onBind(Intent intent)
  
boolean onUnbind(Intent intent)
  
void onRebind(Intent intent)

service_lifecycle

&nbsp;

Broadcast receiver lifecycle
  
只有一个方法：void onReceive(Context curContext, Intent broadcastMsg)

A process with an active broadcast receiver is protected from being killed. But a process with only inactive components can be killed by the system at any time, when the memory it consumes is needed by other processes.

This presents a problem when the response to a broadcast message is time consuming and, therefore, something that should be done in a separate thread, away from the main thread where other components of the user interface run. IfonReceive() spawns the thread and then returns, the entire process, including the new thread, is judged to be inactive (unless other application components are active in the process), putting it in jeopardy of being killed. The solution to this problem is for onReceive() to start a service and let the service do the job, so the system knows that there is still active work being done in the process.

进程的生命周期
  
Android根据其重要性在内存不足的时候移去重要性最低的进程。重要性由高到低为：

前台进程
  
可见进程
  
服务进程
  
后台进程
  
空进程
  
注意：Because a process running a service is ranked higher than one with background activities, an activity that initiates a long-running operation might do well to start a service for that operation, rather than simply spawn a thread — particularly if the operation will likely outlast the activity. 比如播放MP3的时候就要启动一个service。

&nbsp;

http://blog.csdn.net/hanyingjie327/article/details/21256793