---
title: Java 锁
author: "-"
date: 2015-03-05T02:32:58+00:00
url: java-lock
categories:
  - java

tags:
  - reprint
---
## Java 锁

# 自旋锁,自适应自旋锁,锁消除,锁膨胀,轻量级锁,偏向锁

### 自旋锁
在互斥同步的时候,对性能影响最大的就是阻塞的实现,挂起线程,恢复线程等的操作都需要用户态转为内核态去完成。这些操作给性能带来了巨大的压力。

​ 虚拟机的开发团也注意到,共享数据的锁定状态只会持续很短的时间。为了这很短的时间让线程挂起,然后转为内核态的时间可能比锁定状态的时间更长。所以,我们可以让等待同步锁的进程不要进入阻塞,而是在原地稍微等待一会儿,不要放弃处理器的执行时间,看看持有锁的线程是不是很快就会释放锁。为了让线程等待,我们可以让线程执行一个 忙循环 (原地自旋) ,这就是自旋锁。

​ 自旋锁在 JDK1.4.2 之后就已经引入,但是默认是关闭的。我们可以使用 -XX:+UseSpinning参数来开启。在 JDK1.6 之后就默认开启了。自旋锁并不是阻塞,所以它避免了用户态到内核态的频繁转化,但是它是要占用处理器的执行时间的。

​ 如果占有对象锁的线程在很短的时间内就执行完,然后释放锁,这样的话,自旋锁的效果就会非常好。

​ 如果占有对象锁的线程执行时间很长,那么自旋锁会白白消耗处理器的执行时间,这就带来了性能的浪费。这样的话,还不如将等待的线程进行阻塞。默认的自旋次数是 10,也就是说,如果一个线程自旋 10 次之后,还没有拿到对象锁,那么就会进行阻塞。

​ 我们也可以使用参数 -XX:PreBlockSpin来更改。

### 自适应自旋锁

​ 无论是使用默认的 10 次,还是用户自定义的次数,对整个虚拟机来说所有的线程都是一样的。但是同一个虚拟机中线程的状态并不是一样的,有的锁对象长一点,有的短一点,所以,在 JDK1.6 的时候,引入了 自适应自旋锁。

​ 自适应自旋锁意味着自旋的时间不在固定了,而是根据当前的情况动态设置。

​ 主要取决于 同一个锁上一次的自旋时间和 锁的拥有者的状态。

​ 如果在同一个对象锁上,上一个获取这个对象锁的线程在自旋等待成功了,没有进入阻塞状态,说明这个对象锁的线程执行时间会很短,虚拟机认为这次也有可能再次成功,进而允许此次自旋时间可以更长一点。

​ 如果对于某个锁,自旋状态下很少获得过锁,说明这个对象锁的线程执行时间相对会长一点,那么以后虚拟机可能会直接省略掉自旋的过程。避免浪费处理器资源。

​ 自适应自旋锁的加入,随着程序运行时间的增长以及性能监控系统信息的不断完善,虚拟机对程序的自旋时间预测越来越准确,也就是 虚拟机越来越聪明了。


###  轻量级锁 (Lightweight Locking)
Java 的多线程安全是基于 Lock 机制实现的,而 Lock 的性能往往不如人意。  
原因是,monitorenter 与 monitorexit 这两个控制多线程同步的 bytecode 原语,是JVM依赖操作系统互斥(mutex)来实现的。  

互斥是一种会导致线程挂起,并在较短的时间内又需要重新调度回原线程的,较为消耗资源的操作。

为了优化Java的Lock机制,从Java6开始引入了轻量级锁的概念。

轻量级锁 (Lightweight Locking) 本意是为了减少多线程进入互斥的几率,并不是要替代互斥。
  
它利用了CPU原语Compare-And-Swap(CAS,汇编指令CMPXCHG),尝试在进入互斥前,进行补救。

本文将详细介绍JVM如何利用CAS,实现轻量级锁。

原理详解
  
Java Object Model中定义,Object Header是一个2字 (1 word = 4 byte) 长度的存储区域。
  
第一个字长度的区域用来标记同步,GC以及hash code等,官方称之为 mark word。第二个字长度的区域是指向到对象的Class。

在2个word中,mark word是轻量级锁实现的关键。它的结构见下表

从表中可以看到,state为lightweight locked的那行即为轻量级锁标记。bitfieds名为指向lock record的指针,这里的lock record,其实是一块分配在线程堆栈上的空间区域。
  
用于CAS前,拷贝object上的mark word(为什么要拷贝,请看下文)。
  
第三项是重量级锁标记。后面的状态单词很有趣,inflated,译为膨胀,在这里意思其实是锁已升级到OS-level。
  
在本文的范围内,我们只关注第二和第三项即可。

为了能直观的理解lock,unlock与mark word之间的联系,我画了一张流程图: 

在图中,提到了拷贝object mark word,由于脱离了原始mark word,官方将它冠以displaced前缀,即displaced mark word(置换标记字)。
  
这个displaced mark word是整个轻量级锁实现的关键,在CAS中的compare就需要用它作为条件。

为什么要拷贝mark word？
  
其实很简单,原因是为了不想在lock与unlock这种底层操作上再加同步。

在拷贝完object mark word之后,JVM做了一步交换指针的操作,即流程中第一个橙色矩形框内容所述。
  
将object mark word里的轻量级锁指针指向lock record所在的stack指针,作用是让其他线程知道,该object monitor已被占用。
  
lock record里的owner指针指向object mark word的作用是为了在接下里的运行过程中,识别哪个对象被锁住了。

下图直观地描述了交换指针的操作。

exchange_pointer_1

最后一步unlock中,我们发现,JVM同样使用了CAS来验证object mark word在持有锁到释放锁之间,有无被其他线程访问。
  
如果其他线程在持有锁这段时间里,尝试获取过锁,则可能自身被挂起,而mark word的重量级锁指针也会被相应修改。
  
此时,unlock后就需要唤醒被挂起的线程。

转载请注明原文链接: http://kenwublog.com/theory-of-lightweight-locking-upon-cas

http://blog.csdn.net/hsuxu/article/details/9472389


https://xie.infoq.cn/article/25f183de98f8f3337f1a70603

